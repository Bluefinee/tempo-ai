# ğŸ“± Phase 1: MVP ã‚³ã‚¢ä½“é¨“å®Ÿè£…è¨ˆç”»æ›¸

**å®Ÿæ–½æœŸé–“**: 3-4é€±é–“  
**å¯¾è±¡èª­è€…**: é–‹ç™ºãƒãƒ¼ãƒ   
**æœ€çµ‚æ›´æ–°**: 2025å¹´12æœˆ5æ—¥  
**å‰ææ¡ä»¶**: Phase 0 å®Œäº†ï¼ˆå“è³ªåŸºç›¤å®‰å®šåŒ–ï¼‰

---

## ğŸ¯ æ¦‚è¦

Phase 1ã§ã¯ã€ä»•æ§˜æ›¸ã«å®šç¾©ã•ã‚ŒãŸæ´—ç·´ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®åŸºç›¤ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ç¾ã—ã„ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼ã€ç’°å¢ƒæƒ…å ±çµ±åˆã€ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰åŒ–ã•ã‚ŒãŸå¥åº·çŠ¶æ…‹ã‚·ã‚¹ãƒ†ãƒ ã€å¤©æ°—å¯¾å¿œæŒ¨æ‹¶ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ç¾åœ¨ã®åŸºæœ¬MVPã‚’é­…åŠ›çš„ãªãƒ˜ãƒ«ã‚¹ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ã‚¢ãƒ—ãƒªã«å¤‰æ›ã—ã¾ã™ã€‚

---

## ğŸ“Š ç¾çŠ¶ã¨ç›®æ¨™

### ç¾åœ¨ã®çŠ¶æ…‹ï¼ˆPhase 0å®Œäº†å¾Œï¼‰
- åŸºæœ¬çš„ãª4ã‚¿ãƒ–ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
- å˜ç´”ãªHomeViewï¼ˆTodayï¼‰
- åŸºæœ¬çš„ãªãƒ˜ãƒ«ã‚¹ãƒ»ä½ç½®æƒ…å ±æ¨©é™ç®¡ç†
- ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹è¡¨ç¤º
- **âœ… æ—¥è‹±å¤šè¨€èªåŒ–åŸºç›¤æ§‹ç¯‰æ¸ˆã¿**

### Phase 1 çµ‚äº†æ™‚ã®ç›®æ¨™
- ğŸŒŸ **4ãƒšãƒ¼ã‚¸ç¾éº—ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼**ï¼ˆ**æ—¥æœ¬èªãƒ»è‹±èªå®Œå…¨å¯¾å¿œ**ï¼‰
- ğŸ¨ **ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰åŒ–ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**ï¼ˆæœ€é©/æ¨™æº–/ã‚±ã‚¢/ä¼‘æ¯ãƒ¢ãƒ¼ãƒ‰ï¼‰
- ğŸŒ¤ï¸ **å¤©æ°—ãƒ»æ™‚é–“å¯¾å¿œãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºæŒ¨æ‹¶**ï¼ˆ**æ—¥æœ¬èªã§ã®è‡ªç„¶ãªè¡¨ç¾**ï¼‰
- âš ï¸ **ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ **ï¼ˆæ°—åœ§ãƒ»èŠ±ç²‰ãƒ»å¤§æ°—è³ªï¼‰
- ğŸ’« **æ´—ç·´ã•ã‚ŒãŸUI/UXä½“é¨“**ï¼ˆ**æ—¥æœ¬èªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæœ€é©åŒ–**ï¼‰

---

## ğŸ“‹ å®Ÿè£…ã‚¿ã‚¹ã‚¯

### 1. ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼å®Ÿè£…

#### 1.1 OnboardingView ã®æ–°è¦ä½œæˆï¼ˆå¤šè¨€èªå®Œå…¨å¯¾å¿œï¼‰
```swift
// ios/TempoAI/TempoAI/Views/Onboarding/OnboardingView.swift
struct OnboardingView: View {
    @StateObject private var localization = LocalizationManager.shared
    @State private var currentPage: Int = 0
    @State private var showingLanguageSelector: Bool = false
    
    var body: some View {
        TabView(selection: $currentPage) {
            WelcomePageView()
                .tag(0)
                .accessibilityIdentifier(UIIdentifiers.Onboarding.welcomePage)
            
            DataExplanationPageView()
                .tag(1)
                .accessibilityIdentifier(UIIdentifiers.Onboarding.dataPage)
            
            AIAnalysisPageView() 
                .tag(2)
                .accessibilityIdentifier(UIIdentifiers.Onboarding.analysisPage)
                
            GetStartedPageView()
                .tag(3)
                .accessibilityIdentifier(UIIdentifiers.Onboarding.getStartedPage)
        }
        .tabViewStyle(.page)
        .toolbar {
            ToolbarItem(placement: .topBarTrailing) {
                Button("language_settings".localized) {
                    showingLanguageSelector = true
                }
            }
        }
        .sheet(isPresented: $showingLanguageSelector) {
            LanguageSelectorView()
        }
    }
}
```

**å®Ÿè£…å†…å®¹ï¼ˆæ—¥è‹±å®Œå…¨å¯¾å¿œï¼‰**:
- **Page 1**: ã‚ˆã†ã“ãç”»é¢ï¼ˆTempo AI ã‚³ãƒ³ã‚»ãƒ—ãƒˆç´¹ä»‹ï¼‰
- **Page 2**: ãƒ‡ãƒ¼ã‚¿çµ±åˆèª¬æ˜ï¼ˆ3ã¤ã®ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹å¯è¦–åŒ–ï¼‰
- **Page 3**: AIåˆ†ææ©Ÿèƒ½èª¬æ˜ï¼ˆåˆ†æãƒ—ãƒ­ã‚»ã‚¹å¯è¦–åŒ–ï¼‰  
- **Page 4**: æ¯æœã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹èª¬æ˜ï¼ˆé–‹å§‹ãƒœã‚¿ãƒ³ï¼‰

#### 1.2 å¤šè¨€èªãƒªã‚½ãƒ¼ã‚¹å®Œå…¨å®Ÿè£…
```swift
// ja.lproj/Localizable.strings
"onboarding_welcome_title" = "Tempo AI ã¸ã‚ˆã†ã“ã";
"onboarding_welcome_subtitle" = "ã‚ãªãŸã ã‘ã®ãƒ˜ãƒ«ã‚¹ã‚±ã‚¢ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼";
"onboarding_welcome_description" = "æ¯æœã€æœ€é©ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ã‚ãªãŸã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç”Ÿæˆã—ã¾ã™";

"onboarding_data_title" = "3ã¤ã®ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆ";
"onboarding_data_body" = "ã‚ãªãŸã®ä½“ã®çŠ¶æ…‹";
"onboarding_data_environment" = "ä»Šæ—¥ã®ç’°å¢ƒ";
"onboarding_data_yesterday" = "æ˜¨æ—¥ã®éã”ã—æ–¹";

"onboarding_analysis_title" = "AIãŒåˆ†æã™ã‚‹ã“ã¨";
"onboarding_analysis_description" = "ä»Šæœã®ã‚ãªãŸã®çŠ¶æ…‹ã¨æ˜¨æ—¥ã®éã”ã—æ–¹ã¨ã®é–¢ä¿‚ã€ä»Šæ—¥ã®ç’°å¢ƒã¸ã®å½±éŸ¿ã‹ã‚‰æœ€é©ãª1æ—¥ã®ãƒ—ãƒ©ãƒ³ã‚’ç”Ÿæˆ";

"onboarding_start_title" = "æ¯æœå±Šãã‚‚ã®";
"onboarding_start_meal" = "é£Ÿäº‹ãƒ—ãƒ©ãƒ³";
"onboarding_start_exercise" = "é‹å‹•ãƒ—ãƒ©ãƒ³";
"onboarding_start_wellness" = "éã”ã—æ–¹ãƒ—ãƒ©ãƒ³";

// en.lproj/Localizable.strings
"onboarding_welcome_title" = "Welcome to Tempo AI";
"onboarding_welcome_subtitle" = "Your Personal Healthcare Advisor";
"onboarding_welcome_description" = "Every morning, optimal advice from your data";
// ... ä»–ã®è‹±èªãƒªã‚½ãƒ¼ã‚¹
```

**å¯¾å¿œè¨€èª**:
- ğŸ‡¯ğŸ‡µ æ—¥æœ¬èªï¼ˆã‚·ã‚¹ãƒ†ãƒ è¨€èªå„ªå…ˆï¼‰
- ğŸ‡ºğŸ‡¸ è‹±èªï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
- ğŸŒ ã‚·ã‚¹ãƒ†ãƒ è‡ªå‹•æ¤œå‡º + æ‰‹å‹•åˆ‡ã‚Šæ›¿ãˆ

### 2. ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰åŒ–ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹

#### 2.1 HealthStatusCalculator å®Ÿè£…
```swift
// ios/TempoAI/TempoAI/Services/HealthStatusCalculator.swift
enum HealthStatusMode: String, CaseIterable {
    case optimal = "optimal"      // ğŸŸ¢ 80-100ç‚¹
    case standard = "standard"    // ğŸŸ¡ 60-79ç‚¹  
    case care = "care"           // ğŸ”µ 40-59ç‚¹
    case rest = "rest"           // âš«ï¸ 0-39ç‚¹
    
    var color: Color { /* ã‚«ãƒ©ãƒ¼å®šç¾© */ }
    var displayText: LocalizedStringKey { /* ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºãƒ†ã‚­ã‚¹ãƒˆ */ }
}

class HealthStatusCalculator {
    static func calculateStatus(from healthData: HealthData) -> HealthStatusMode
    static func generateStatusDescription(mode: HealthStatusMode, data: HealthData) -> String
}
```

#### 2.2 StatusIndicatorView ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
```swift
// ios/TempoAI/TempoAI/Views/Components/StatusIndicatorView.swift
struct StatusIndicatorView: View {
    let mode: HealthStatusMode
    let score: Int
    
    var body: some View {
        // è¦–è¦šçš„ãªã‚¹ã‚³ã‚¢ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ + ãƒ†ã‚­ã‚¹ãƒˆèª¬æ˜
    }
}
```

### 3. å¤©æ°—å¯¾å¿œãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºæŒ¨æ‹¶

#### 3.1 GreetingService ã®æ‹¡å¼µ
```swift
// ios/TempoAI/TempoAI/Services/GreetingService.swift
struct GreetingService {
    static func generateGreeting(
        weather: Weather,
        time: Date,
        userName: String?,
        language: String
    ) -> String {
        // ä»•æ§˜æ›¸ã®æŒ¨æ‹¶ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…
    }
}

enum WeatherCondition {
    case sunny, cloudy, rainy, snowy
    case hot, warm, cool, cold
}
```

#### 3.2 æ™‚é–“å¸¯ãƒ»æ°—è±¡åˆ¥æŒ¨æ‹¶ãƒ‘ã‚¿ãƒ¼ãƒ³
**æ—¥æœ¬èªãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…ä¾‹**:
```swift
// ja.lproj/Localizable.strings ã§ã®å®Ÿè£…
"greeting_sunny_morning" = "å¿«æ™´ã®æœã§ã™ã­ã€%@ã•ã‚“";
"greeting_rainy_afternoon" = "é›¨ã®åˆå¾Œã§ã™ãŒä½“èª¿ç®¡ç†ã—ã£ã‹ã‚Šã¨ã€%@ã•ã‚“";
"greeting_cold_night" = "å¯’ã„å¤œã§ã™ã­ã€æ¸©ã‹ãã—ã¦ãã ã•ã„";
"greeting_cloudy_morning" = "æ›‡ã‚Šç©ºã§ã™ãŒå…ƒæ°—ã«ã„ãã¾ã—ã‚‡ã†ã€%@ã•ã‚“";

// en.lproj/Localizable.strings ã§ã®å®Ÿè£…  
"greeting_sunny_morning" = "Beautiful morning, %@!";
"greeting_rainy_afternoon" = "Rainy afternoon but stay healthy, %@!";
"greeting_cold_night" = "Cold night, stay warm";
"greeting_cloudy_morning" = "Good morning, %@!";
```

### 4. ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ 

#### 4.1 EnvironmentalAlertView å®Ÿè£…  
```swift
// ios/TempoAI/TempoAI/Views/Components/EnvironmentalAlertView.swift
struct EnvironmentalAlertView: View {
    let alerts: [EnvironmentalAlert]
    
    var body: some View {
        // æ°—åœ§ãƒ»èŠ±ç²‰ãƒ»å¤§æ°—è³ªã‚¢ãƒ©ãƒ¼ãƒˆã®è¡¨ç¤º
    }
}

struct EnvironmentalAlert {
    let type: AlertType
    let severity: AlertSeverity
    let message: String
    let actionText: String?
}

enum AlertType {
    case pressure, pollen, airQuality, uv
}
```

#### 4.2 ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ç’°å¢ƒãƒ‡ãƒ¼ã‚¿æ‹¡å¼µ
```typescript
// backend/src/services/environmental-service.ts
export const getEnvironmentalAlerts = async (
  weather: WeatherData,
  location: Location
): Promise<EnvironmentalAlert[]> => {
  // æ°—åœ§ä½ä¸‹ã€èŠ±ç²‰ãƒ¬ãƒ™ãƒ«ã€AQIã€UVæŒ‡æ•°ã‹ã‚‰ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ
}
```

### 5. HomeView ã®æ´—ç·´åŒ–

#### 5.1 æ–°ã—ã„HomeViewæ§‹é€ 
```swift
// ios/TempoAI/TempoAI/Views/HomeView.swift - å¤§å¹…ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
struct HomeView: View {
    @StateObject private var viewModel: HomeViewModel
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                PersonalizedHeaderView()      // æŒ¨æ‹¶ + ç’°å¢ƒæƒ…å ±
                EnvironmentalAlertsView()     // ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆ
                HealthStatusCardView()        // ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰åŒ–ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
                TodayAdviceCardsView()        // ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚«ãƒ¼ãƒ‰ç¾¤
            }
        }
    }
}
```

#### 5.2 HomeViewModel ã®å®Ÿè£…
```swift
// ios/TempoAI/TempoAI/ViewModels/HomeViewModel.swift
@MainActor
class HomeViewModel: ObservableObject {
    @Published var healthStatus: HealthStatusMode?
    @Published var environmentalAlerts: [EnvironmentalAlert] = []
    @Published var personalizedGreeting: String = ""
    @Published var todayAdvice: DailyAdvice?
    
    func loadTodayData() async
    func refreshWeatherAndAlerts() async  
    func calculateHealthStatus() async
}
```

---

## ğŸ¨ UI/UX è¨­è¨ˆè©³ç´°

### ã‚«ãƒ©ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ—¥è‹±å…±é€šï¼‰
```swift
extension Color {
    static let healthOptimal = Color.green      // ğŸŸ¢ æœ€é©ãƒ¢ãƒ¼ãƒ‰
    static let healthStandard = Color.yellow    // ğŸŸ¡ æ¨™æº–ãƒ¢ãƒ¼ãƒ‰  
    static let healthCare = Color.blue          // ğŸ”µ ã‚±ã‚¢ãƒ¢ãƒ¼ãƒ‰
    static let healthRest = Color.black         // âš«ï¸ ä¼‘æ¯ãƒ¢ãƒ¼ãƒ‰
    
    static let alertWarning = Color.orange      // âš ï¸ ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆ
    static let alertDanger = Color.red          // ğŸš¨ é‡è¦ã‚¢ãƒ©ãƒ¼ãƒˆ
}
```

### å¤šè¨€èªå¯¾å¿œã‚¿ã‚¤ãƒã‚°ãƒ©ãƒ•ã‚£
```swift
extension Font {
    static let greetingTitle = Font.title2.bold()
    static let statusScore = Font.largeTitle.monospacedDigit()
    static let alertText = Font.caption.weight(.medium)
    static let adviceTitle = Font.headline
    
    // æ—¥æœ¬èªæœ€é©åŒ–
    static let japaneseBody = Font.system(.body, design: .default)
        .leading(.loose)  // è¡Œé–“ã‚’åºƒã‚ã«
    static let japaneseTitle = Font.system(.title2, design: .default, weight: .semibold)
    
    // è‹±èªæœ€é©åŒ–  
    static let englishBody = Font.body
    static let englishTitle = Font.title2.bold()
}
```

### ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆé©å¿œ
```swift
// è¨€èªã«å¿œã˜ãŸå‹•çš„ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´
struct LocalizedLayoutModifier: ViewModifier {
    @StateObject private var localization = LocalizationManager.shared
    
    func body(content: Content) -> some View {
        content
            .font(localization.isJapanese ? .japaneseBody : .englishBody)
            .lineSpacing(localization.isJapanese ? 4 : 2)
            .environment(\.layoutDirection, localization.isJapanese ? .leftToRight : .leftToRight)
    }
}
```

### ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´æ™‚: ã‚¹ãƒ ãƒ¼ã‚¹ã‚«ãƒ©ãƒ¼ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ï¼ˆ0.3ç§’ï¼‰
- ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º: ã‚¹ãƒ©ã‚¤ãƒ‰ã‚¤ãƒ³ + ãƒ‘ãƒ«ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒšãƒ¼ã‚¸é·ç§»: æ¨ªã‚¹ãƒ©ã‚¤ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- è¨€èªåˆ‡ã‚Šæ›¿ãˆ: ãƒ•ã‚§ãƒ¼ãƒ‰ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ï¼ˆ0.2ç§’ï¼‰

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### iOS UIãƒ†ã‚¹ãƒˆæ‹¡å¼µï¼ˆå¤šè¨€èªå¯¾å¿œï¼‰
```swift
// ios/TempoAI/TempoAIUITests/OnboardingUITests.swift
class OnboardingUITests: XCTestCase {
    func testOnboardingFlowCompleteJapanese()     // æ—¥æœ¬èªãƒ•ãƒ­ãƒ¼
    func testOnboardingFlowCompleteEnglish()      // è‹±èªãƒ•ãƒ­ãƒ¼
    func testLanguageSwitchingDuringOnboarding() // é€”ä¸­è¨€èªåˆ‡ã‚Šæ›¿ãˆ
    func testPermissionRequestFlowLocalized()    // å¤šè¨€èªæ¨©é™è¦æ±‚
    func testOnboardingSkipFunctionality()       // ã‚¹ã‚­ãƒƒãƒ—æ©Ÿèƒ½
}

// ios/TempoAI/TempoAIUITests/HomeViewUITests.swift  
class HomeViewUITests: XCTestCase {
    func testHealthStatusDisplayJapanese()       // æ—¥æœ¬èªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
    func testHealthStatusDisplayEnglish()        // è‹±èªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
    func testEnvironmentalAlertsLocalized()      // å¤šè¨€èªç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆ
    func testPersonalizedGreetingVariations()   // æŒ¨æ‹¶ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
    func testWeatherIntegrationWithLocalization() // å¤šè¨€èªå¤©æ°—çµ±åˆ
}

// ios/TempoAI/TempoAIUITests/LocalizationUITests.swift
class LocalizationUITests: XCTestCase {
    func testLanguageSwitchPreservesData()      // è¨€èªåˆ‡ã‚Šæ›¿ãˆæ™‚ãƒ‡ãƒ¼ã‚¿ä¿æŒ
    func testJapaneseLayoutOptimization()       // æ—¥æœ¬èªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæœ€é©åŒ–
    func testEnglishLayoutOptimization()        // è‹±èªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæœ€é©åŒ–
    func testSystemLanguageDetection()          // ã‚·ã‚¹ãƒ†ãƒ è¨€èªè‡ªå‹•æ¤œå‡º
}
```

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIãƒ†ã‚¹ãƒˆæ‹¡å¼µ
```typescript
// backend/tests/services/environmental-service.test.ts
describe('Environmental Service', () => {
  it('should generate pressure drop alerts')
  it('should calculate pollen level warnings')
  it('should assess air quality alerts')
  it('should provide UV index recommendations')
})
```

### ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
```swift
// ios/TempoAI/TempoAITests/Mock/MockHealthData.swift
struct MockHealthData {
    static let optimalStatus: HealthData  // 80-100ç‚¹ç¯„å›²
    static let careStatus: HealthData     // 40-59ç‚¹ç¯„å›²
    static let restStatus: HealthData     // 0-39ç‚¹ç¯„å›²
}
```

---

## ğŸ“¦ æˆæœç‰©

### æ–°è¦ä½œæˆãƒ•ã‚¡ã‚¤ãƒ«
```
ios/TempoAI/TempoAI/
â”œâ”€â”€ Views/
â”‚   â”œâ”€â”€ Onboarding/
â”‚   â”‚   â”œâ”€â”€ OnboardingView.swift
â”‚   â”‚   â”œâ”€â”€ WelcomePageView.swift
â”‚   â”‚   â”œâ”€â”€ DataExplanationView.swift
â”‚   â”‚   â”œâ”€â”€ AIAnalysisView.swift
â”‚   â”‚   â””â”€â”€ GetStartedView.swift
â”‚   â””â”€â”€ Components/
â”‚       â”œâ”€â”€ StatusIndicatorView.swift
â”‚       â”œâ”€â”€ EnvironmentalAlertView.swift
â”‚       â”œâ”€â”€ PersonalizedHeaderView.swift
â”‚       â””â”€â”€ HealthStatusCardView.swift
â”œâ”€â”€ ViewModels/
â”‚   â”œâ”€â”€ HomeViewModel.swift
â”‚   â””â”€â”€ OnboardingViewModel.swift
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ HealthStatusCalculator.swift
â”‚   â”œâ”€â”€ GreetingService.swift
â”‚   â””â”€â”€ EnvironmentalAlertService.swift
â””â”€â”€ Localization/
    â”œâ”€â”€ ja.lproj/Localizable.strings
    â””â”€â”€ en.lproj/Localizable.strings
```

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰æ‹¡å¼µ
```
backend/src/
â”œâ”€â”€ services/
â”‚   â””â”€â”€ environmental-service.ts
â”œâ”€â”€ types/
â”‚   â””â”€â”€ environmental.ts
â””â”€â”€ utils/
    â””â”€â”€ localization.ts
```

---

## â±ï¸ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

| Week | ã‚¿ã‚¹ã‚¯ | æˆæœç‰© |
|------|--------|--------|
| **Week 1** | ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼ + å¤šè¨€èªå¯¾å¿œ | OnboardingViewå®Œæˆ |
| **Week 2** | ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚·ã‚¹ãƒ†ãƒ  + HomeViewæ´—ç·´åŒ– | ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰åŒ–ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º |  
| **Week 3** | ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ  + ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºæŒ¨æ‹¶ | å¤©æ°—å¯¾å¿œæŒ¨æ‹¶ + ã‚¢ãƒ©ãƒ¼ãƒˆ |
| **Week 4** | çµ±åˆãƒ†ã‚¹ãƒˆ + UI/UXç£¨ãä¸Šã’ + Phase 2æº–å‚™ | å®Œå…¨å‹•ä½œPhase 1 |

---

## ğŸ¯ æˆåŠŸåŸºæº–

### æ©Ÿèƒ½å®Œäº†åŸºæº–
- [ ] 4ãƒšãƒ¼ã‚¸ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼ãŒ**æ—¥è‹±ä¸¡è¨€èªã§å®Œå…¨å‹•ä½œ**
- [ ] ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒ4è‰²ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã§æ­£ç¢ºã«è¡¨ç¤º  
- [ ] å¤©æ°—ãƒ»æ™‚é–“å¸¯ã«å¿œã˜ãŸæŒ¨æ‹¶ãŒå‹•çš„ã«å¤‰åŒ–ï¼ˆ**æ—¥æœ¬èªè‡ªç„¶è¡¨ç¾**ï¼‰
- [ ] ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆï¼ˆæ°—åœ§ãƒ»èŠ±ç²‰ãƒ»AQIï¼‰ãŒé©åˆ‡ã«è¡¨ç¤º
- [ ] å…¨UIè¦ç´ ãŒã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£è­˜åˆ¥å­ä»˜ãã§ãƒ†ã‚¹ãƒˆå¯èƒ½
- [ ] **è¨€èªåˆ‡ã‚Šæ›¿ãˆãŒå³åº§ã«å…¨UIã«åæ˜ **

### å“è³ªåŸºæº–
- [ ] iOS UIãƒ†ã‚¹ãƒˆç¶²ç¾…ç‡: æ–°æ©Ÿèƒ½90%ä»¥ä¸Šï¼ˆ**å¤šè¨€èªãƒ†ã‚¹ãƒˆå«ã‚€**ï¼‰
- [ ] ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: 95%ä»¥ä¸Šç¶­æŒ  
- [ ] SwiftLint/swift-format: ã‚¨ãƒ©ãƒ¼0ä»¶
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹: Homeãƒ“ãƒ¥ãƒ¼èª­ã¿è¾¼ã¿1ç§’ä»¥å†…
- [ ] **å¤šè¨€èª: æ—¥æœ¬èªãƒ»è‹±èªè¡¨ç¤ºã®æ•´åˆæ€§100%**
- [ ] **å¤šè¨€èªãƒªã‚½ãƒ¼ã‚¹: 200é …ç›®ä»¥ä¸Šå®Œå‚™**

### å¤šè¨€èªå“è³ªåŸºæº–  
- [ ] **æ—¥æœ¬èªUI**: ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå´©ã‚Œ0ä»¶ã€è‡ªç„¶ãªè¡¨ç¾
- [ ] **è‹±èªUI**: ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ¬ãƒ™ãƒ«ã®è¡¨ç¾å“è³ª
- [ ] **è¨€èªåˆ‡ã‚Šæ›¿ãˆ**: 0.2ç§’ä»¥å†…ã®é«˜é€Ÿåˆ‡ã‚Šæ›¿ãˆ
- [ ] **ãƒ•ã‚©ãƒ³ãƒˆæœ€é©åŒ–**: æ—¥è‹±ãã‚Œãã‚Œã®èª­ã¿ã‚„ã™ã•ç¢ºä¿

### ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£åŸºæº–  
- [ ] ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Œäº†ç‡: ãƒ†ã‚¹ãƒˆç’°å¢ƒ90%ä»¥ä¸Š
- [ ] ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç†è§£åº¦: è‰²ã¨ãƒ†ã‚­ã‚¹ãƒˆã®æ˜ç¢ºãªå¯¾å¿œ
- [ ] ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆæœ‰ç”¨æ€§: å®Ÿéš›ã®æ°—è±¡æ¡ä»¶ã¨ã®æ•´åˆæ€§

---

## ğŸ”„ Next Phase

Phase 1 å®Œäº†å¾Œã€å……å®Ÿã—ãŸã‚³ã‚¢ä½“é¨“ã®åŸºç›¤ä¸Šã« Phase 2ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“å‘ä¸Šï¼‰ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

### Phase 2ã¸ã®å¼•ãç¶™ã
- **å®ŒæˆåŸºç›¤**: ç¾éº—ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚° + ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰åŒ–ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ + ç’°å¢ƒå¯¾å¿œ
- **æº–å‚™äº‹é …**: æœã®ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³æ©Ÿèƒ½ã€è©³ç´°ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”»é¢ã®è¨­è¨ˆ  
- **æŠ€è¡“è² å‚µ**: å¤šè¨€èªå¯¾å¿œã®æ‹¡å¼µæ€§ç¢ºä¿ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

---

**ğŸŒŸ Phase 1 å®Œäº†ã«ã‚ˆã‚Šã€Tempo AIã¯å˜ãªã‚‹MVPã‹ã‚‰çœŸã®ãƒ˜ãƒ«ã‚¹ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ä½“é¨“ã¸ã¨é€²åŒ–ã—ã¾ã™**

---

## ğŸ“‹ å®Ÿè£…æº–å‚™: è¦ä»¶è©³ç´°ãƒãƒƒãƒ”ãƒ³ã‚°

### ä»•æ§˜æ›¸ã¨ã®å¯¾å¿œé–¢ä¿‚

#### 1. ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼ä»•æ§˜å¯¾å¿œ

**ä»•æ§˜æ›¸ã‚»ã‚¯ã‚·ãƒ§ãƒ³**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚° (Section 4.1)

| ä»•æ§˜è¦ä»¶ | å®Ÿè£…ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | æ¤œè¨¼æ–¹æ³• |
|----------|-------------------|----------|
| **4ãƒšãƒ¼ã‚¸æ®µéšçš„å°å…¥** | OnboardingView + TabView | UIãƒ†ã‚¹ãƒˆ: ãƒšãƒ¼ã‚¸é·ç§»ãƒ•ãƒ­ãƒ¼ |
| **è¨€èªé¸æŠæ©Ÿèƒ½** | LanguageSelectorView | UIãƒ†ã‚¹ãƒˆ: è¨€èªåˆ‡ã‚Šæ›¿ãˆå‹•ä½œ |
| **æ¨©é™è¦æ±‚çµ±åˆ** | PermissionRequestView | UIãƒ†ã‚¹ãƒˆ: æ¨©é™è¨±å¯ãƒ•ãƒ­ãƒ¼ |
| **ã‚¹ã‚­ãƒƒãƒ—æ©Ÿèƒ½** | OnboardingCoordinator | UIãƒ†ã‚¹ãƒˆ: ã‚¹ã‚­ãƒƒãƒ—ãƒœã‚¿ãƒ³å‹•ä½œ |
| **ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤º** | PageControl + ProgressView | UIãƒ†ã‚¹ãƒˆ: é€²æ—è¡¨ç¤ºç²¾åº¦ |

**å®Ÿè£…è¦æ¨¡**: 5ãƒ•ã‚¡ã‚¤ãƒ«æ–°è¦ä½œæˆã€3ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µ
**ãƒ†ã‚¹ãƒˆè¦æ¨¡**: 15 UIãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã€8 ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

#### 2. ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ä»•æ§˜å¯¾å¿œ

**ä»•æ§˜æ›¸ã‚»ã‚¯ã‚·ãƒ§ãƒ³**: ãƒ˜ãƒ«ã‚¹çŠ¶æ…‹è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ  (Section 3.2)

| ä»•æ§˜è¦ä»¶ | å®Ÿè£…ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | æ¤œè¨¼æ–¹æ³• |
|----------|-------------------|----------|
| **4æ®µéšã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰** | HealthStatusMode enum | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: ã‚¹ã‚³ã‚¢â†’ã‚«ãƒ©ãƒ¼å¤‰æ› |
| **å‹•çš„ã‚¹ã‚³ã‚¢è¨ˆç®—** | HealthStatusCalculator | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯æ­£ç¢ºæ€§ |
| **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°** | HomeViewModel | çµ±åˆãƒ†ã‚¹ãƒˆ: ãƒ‡ãƒ¼ã‚¿æ›´æ–°åæ˜  |
| **å¤šè¨€èªè¡¨ç¤º** | LocalizedHealthStatus | UIãƒ†ã‚¹ãƒˆ: è¨€èªåˆ‡ã‚Šæ›¿ãˆè¡¨ç¤º |
| **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£** | VoiceOverå¯¾å¿œ | ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ |

**å®Ÿè£…è¦æ¨¡**: 3ãƒ•ã‚¡ã‚¤ãƒ«æ–°è¦ä½œæˆã€2ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µ
**ãƒ†ã‚¹ãƒˆè¦æ¨¡**: 12 ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã€8 UIãƒ†ã‚¹ãƒˆ

#### 3. å¤©æ°—å¯¾å¿œæŒ¨æ‹¶ä»•æ§˜å¯¾å¿œ

**ä»•æ§˜æ›¸ã‚»ã‚¯ã‚·ãƒ§ãƒ³**: ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºæŒ¨æ‹¶ã‚·ã‚¹ãƒ†ãƒ  (Section 3.3)

| ä»•æ§˜è¦ä»¶ | å®Ÿè£…ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | æ¤œè¨¼æ–¹æ³• |
|----------|-------------------|----------|
| **æ™‚é–“å¸¯åˆ¥æŒ¨æ‹¶** | GreetingService.timeBasedGreeting | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: æ™‚é–“å¸¯åˆ¤å®š |
| **å¤©æ°—é€£å‹•æŒ¨æ‹¶** | GreetingService.weatherGreeting | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: å¤©æ°—åˆ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ |
| **å€‹äººåçµ±åˆ** | PersonalizedHeaderView | UIãƒ†ã‚¹ãƒˆ: åå‰è¡¨ç¤º |
| **æ–‡åŒ–çš„é©å¿œ** | JapaneseGreetingPatterns | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: æ—¥æœ¬èªè¡¨ç¾è‡ªç„¶æ€§ |
| **å‹•çš„æ›´æ–°** | GreetingRefreshService | çµ±åˆãƒ†ã‚¹ãƒˆ: å®šæœŸæ›´æ–°å‹•ä½œ |

**å®Ÿè£…è¦æ¨¡**: 2ãƒ•ã‚¡ã‚¤ãƒ«æ–°è¦ä½œæˆã€3ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µ
**ãƒ†ã‚¹ãƒˆè¦æ¨¡**: 18 ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã€6 UIãƒ†ã‚¹ãƒˆ

#### 4. ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆä»•æ§˜å¯¾å¿œ

**ä»•æ§˜æ›¸ã‚»ã‚¯ã‚·ãƒ§ãƒ³**: ç’°å¢ƒæƒ…å ±çµ±åˆ (Section 2.3)

| ä»•æ§˜è¦ä»¶ | å®Ÿè£…ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | æ¤œè¨¼æ–¹æ³• |
|----------|-------------------|----------|
| **æ°—åœ§å¤‰åŒ–æ¤œçŸ¥** | PressureAlertCalculator | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: ã—ãã„å€¤åˆ¤å®š |
| **èŠ±ç²‰ãƒ¬ãƒ™ãƒ«è­¦å‘Š** | PollenLevelService | APIãƒ†ã‚¹ãƒˆ: å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿å–å¾— |
| **å¤§æ°—è³ªã‚¢ãƒ©ãƒ¼ãƒˆ** | AirQualityAssessment | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: AQIåˆ†æ |
| **é‡è¦åº¦åˆ¥è¡¨ç¤º** | AlertSeverityIndicator | UIãƒ†ã‚¹ãƒˆ: è‰²åˆ†ã‘è¡¨ç¤º |
| **ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ææ¡ˆ** | AlertActionGenerator | ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: ææ¡ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆ |

**å®Ÿè£…è¦æ¨¡**: 4ãƒ•ã‚¡ã‚¤ãƒ«æ–°è¦ä½œæˆã€2ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µ
**ãƒ†ã‚¹ãƒˆè¦æ¨¡**: 15 ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã€ 10 çµ±åˆãƒ†ã‚¹ãƒˆ

### ä»•æ§˜æ›¸æœªã‚«ãƒãƒ¼è¦ç´ ã®è­˜åˆ¥

#### è¿½åŠ å®Ÿè£…ãŒå¿…è¦ãªä»•æ§˜è¦ç´ 

1. **ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è©³ç´°åŒ–**
   - ä»•æ§˜: å¹´é½¢ãƒ»æ€§åˆ¥ãƒ»è·æ¥­ã«ã‚ˆã‚‹å€‹åˆ¥åŒ–
   - å®Ÿè£…: UserProfileDetailView (Phase 2é€ã‚Š)

2. **é«˜åº¦ãªæ–‡åŒ–é©å¿œ**
   - ä»•æ§˜: åœ°åŸŸåˆ¥æ…£ç¿’ãƒ»é£Ÿäº‹æ–‡åŒ–å¯¾å¿œ
   - å®Ÿè£…: CulturalAdaptationEngine (Phase 2ã§å®Ÿè£…æ¸ˆã¿)

3. **è©³ç´°åˆ†æçµæœè¡¨ç¤º**
   - ä»•æ§˜: AIåˆ†æéç¨‹ã®å¯è¦–åŒ–
   - å®Ÿè£…: AnalysisDetailsView (Phase 2é€ã‚Š)

#### Phase 1å®Ÿè£…ç¯„å›²ã®æ­£å½“åŒ–

**å«ã‚ã‚‹ç†ç”±**:
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¬¬ä¸€å°è±¡ã‚’æ±ºå®šã™ã‚‹è¦ç´ ï¼ˆã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
- æ¯æ—¥ã®ä½¿ç”¨ä½“é¨“ã®åŸºç›¤ï¼ˆãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ»æŒ¨æ‹¶ï¼‰
- å®‰å…¨æ€§ã«é–¢ã‚ã‚‹è¦ç´ ï¼ˆç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆï¼‰

**Phase 2é€ã‚Šã®ç†ç”±**:
- åŸºç›¤ä½“é¨“ç¢ºç«‹å¾Œã®ä»˜åŠ ä¾¡å€¤è¦ç´ 
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãŒå¿…è¦ãªå€‹åˆ¥åŒ–è¦ç´ 
- æŠ€è¡“çš„è¤‡é›‘æ€§ãŒé«˜ã„æ©Ÿèƒ½

---

## ğŸ§ª TDDå®Ÿè£…æˆ¦ç•¥: Red-Green-Blue-Verify

### TDDå®Ÿè£…ã‚µã‚¤ã‚¯ãƒ«å®šç¾©

#### Phase 1å°‚ç”¨TDDãƒ—ãƒ­ã‚»ã‚¹

```mermaid
graph LR
    A[ğŸ”´ RED: ãƒ†ã‚¹ãƒˆå¤±æ•—] --> B[ğŸŸ¢ GREEN: æœ€å°å®Ÿè£…]
    B --> C[ğŸ”µ BLUE: ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°]
    C --> D[âœ… VERIFY: çµ±åˆç¢ºèª]
    D --> A
```

**Cycle æ™‚é–“**: å„ã‚µã‚¤ã‚¯ãƒ«15-30åˆ†
**Daily Goal**: 6-8ã‚µã‚¤ã‚¯ãƒ«å®Œäº†
**é€±é–“ãƒ¬ãƒ“ãƒ¥ãƒ¼**: é‡‘æ›œæ—¥ã«ç´¯ç©å“è³ªç¢ºèª

### 1. ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼TDD

#### 1.1 REDæ®µéš: ãƒ†ã‚¹ãƒˆå¤±æ•—ä½œæˆ

```swift
// ios/TempoAI/TempoAITests/Onboarding/OnboardingViewModelTests.swift
class OnboardingViewModelTests: XCTestCase {
    
    // ğŸ”´ RED: åŸºæœ¬ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—ãƒ†ã‚¹ãƒˆ
    func testOnboardingNavigationFlow() {
        let viewModel = OnboardingViewModel()
        
        // åˆæœŸçŠ¶æ…‹ãƒ†ã‚¹ãƒˆ
        XCTAssertEqual(viewModel.currentPage, 0)
        XCTAssertFalse(viewModel.isCompleted)
        
        // æ¬¡ãƒšãƒ¼ã‚¸é·ç§»ãƒ†ã‚¹ãƒˆ
        viewModel.nextPage()
        XCTAssertEqual(viewModel.currentPage, 1) // ğŸ”´ FAIL: nextPage()æœªå®Ÿè£…
        
        // å®Œäº†çŠ¶æ…‹ãƒ†ã‚¹ãƒˆ
        viewModel.completeOnboarding()
        XCTAssertTrue(viewModel.isCompleted) // ğŸ”´ FAIL: completeOnboarding()æœªå®Ÿè£…
    }
    
    // ğŸ”´ RED: è¨€èªåˆ‡ã‚Šæ›¿ãˆå¤±æ•—ãƒ†ã‚¹ãƒˆ
    func testLanguageSwitchingDuringOnboarding() {
        let viewModel = OnboardingViewModel()
        
        // æ—¥æœ¬èªè¨­å®šãƒ†ã‚¹ãƒˆ
        viewModel.switchLanguage(to: .japanese)
        XCTAssertEqual(viewModel.selectedLanguage, .japanese) // ğŸ”´ FAIL: switchLanguage()æœªå®Ÿè£…
        
        // ãƒ‡ãƒ¼ã‚¿ä¿æŒãƒ†ã‚¹ãƒˆ
        viewModel.nextPage()
        let currentPage = viewModel.currentPage
        viewModel.switchLanguage(to: .english)
        XCTAssertEqual(viewModel.currentPage, currentPage) // ğŸ”´ FAIL: è¨€èªåˆ‡ã‚Šæ›¿ãˆæ™‚çŠ¶æ…‹ä¿æŒæœªå®Ÿè£…
    }
}
```

#### 1.2 GREENæ®µéš: æœ€å°å®Ÿè£…

```swift
// ios/TempoAI/TempoAI/ViewModels/OnboardingViewModel.swift
@MainActor
class OnboardingViewModel: ObservableObject {
    @Published var currentPage: Int = 0
    @Published var isCompleted: Bool = false
    @Published var selectedLanguage: Language = .japanese
    
    // ğŸŸ¢ GREEN: æœ€å°å®Ÿè£…ã§ãƒ†ã‚¹ãƒˆé€šé
    func nextPage() {
        currentPage += 1
    }
    
    func completeOnboarding() {
        isCompleted = true
    }
    
    func switchLanguage(to language: Language) {
        selectedLanguage = language
        // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸çŠ¶æ…‹ã¯ä¿æŒï¼ˆå¤‰æ›´ã—ãªã„ï¼‰
    }
}

enum Language {
    case japanese, english
}
```

#### 1.3 BLUEæ®µéš: ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

```swift
// ios/TempoAI/TempoAI/ViewModels/OnboardingViewModel.swift - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¾Œ
@MainActor
class OnboardingViewModel: ObservableObject {
    @Published var currentPage: Int = 0
    @Published var isCompleted: Bool = false
    @Published var selectedLanguage: Language = Language.systemDefault
    
    private let totalPages = 4
    private let localizationManager = LocalizationManager.shared
    
    // ğŸ”µ BLUE: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¿½åŠ 
    func nextPage() {
        guard currentPage < totalPages - 1 else { return }
        currentPage += 1
    }
    
    // ğŸ”µ BLUE: å®Œäº†æ¡ä»¶è¿½åŠ 
    func completeOnboarding() {
        guard currentPage == totalPages - 1 else { return }
        isCompleted = true
        UserDefaults.standard.set(true, forKey: "onboarding_completed")
    }
    
    // ğŸ”µ BLUE: è¨€èªåˆ‡ã‚Šæ›¿ãˆæ‹¡å¼µ
    func switchLanguage(to language: Language) {
        selectedLanguage = language
        localizationManager.setLanguage(language)
        // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã¨ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ã‚’ä¿æŒ
    }
    
    // ğŸ”µ BLUE: ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰è¿½åŠ 
    var canProceedToNext: Bool {
        currentPage < totalPages - 1
    }
    
    var isOnFinalPage: Bool {
        currentPage == totalPages - 1
    }
}
```

#### 1.4 VERIFYæ®µéš: çµ±åˆç¢ºèª

```swift
// ios/TempoAI/TempoAIUITests/OnboardingIntegrationUITests.swift
class OnboardingIntegrationUITests: XCTestCase {
    
    // âœ… VERIFY: ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰çµ±åˆãƒ†ã‚¹ãƒˆ
    func testCompleteOnboardingFlowWithLanguageSwitch() {
        let app = XCUIApplication()
        app.launch()
        
        // åˆæœŸè¡¨ç¤ºç¢ºèª
        XCTAssertTrue(app.buttons[UIIdentifiers.Onboarding.nextButton].exists)
        XCTAssertTrue(app.buttons[UIIdentifiers.Onboarding.languageSelector].exists)
        
        // è¨€èªåˆ‡ã‚Šæ›¿ãˆãƒ•ãƒ­ãƒ¼
        app.buttons[UIIdentifiers.Onboarding.languageSelector].tap()
        app.buttons["English"].tap()
        waitForElementToAppear(app.staticTexts["Welcome to Tempo AI"])
        
        // ãƒšãƒ¼ã‚¸é€²è¡Œãƒ•ãƒ­ãƒ¼  
        for page in 0..<4 {
            if page < 3 {
                app.buttons[UIIdentifiers.Onboarding.nextButton].tap()
                waitForPageTransition(page: page + 1)
            } else {
                app.buttons[UIIdentifiers.Onboarding.getStartedButton].tap()
            }
        }
        
        // å®Œäº†ç¢ºèª
        waitForElementToAppear(app.buttons[UIIdentifiers.Navigation.homeTab])
        XCTAssertTrue(app.buttons[UIIdentifiers.Navigation.homeTab].isSelected)
    }
}
```

### 2. ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹TDD

#### 2.1 REDæ®µéš: è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯å¤±æ•—ãƒ†ã‚¹ãƒˆ

```swift
// ios/TempoAI/TempoAITests/Services/HealthStatusCalculatorTests.swift
class HealthStatusCalculatorTests: XCTestCase {
    
    // ğŸ”´ RED: ã‚¹ã‚³ã‚¢è¨ˆç®—å¤±æ•—ãƒ†ã‚¹ãƒˆ
    func testHealthScoreCalculation() {
        let mockOptimalData = MockHealthData.optimal
        let score = HealthStatusCalculator.calculateScore(from: mockOptimalData)
        XCTAssertGreaterThanOrEqual(score, 80) // ğŸ”´ FAIL: calculateScoreæœªå®Ÿè£…
        XCTAssertLessThanOrEqual(score, 100)
        
        let mockCareData = MockHealthData.care
        let careScore = HealthStatusCalculator.calculateScore(from: mockCareData)
        XCTAssertGreaterThanOrEqual(careScore, 40) // ğŸ”´ FAIL: ç¯„å›²åˆ¤å®šæœªå®Ÿè£…
        XCTAssertLessThanOrEqual(careScore, 59)
    }
    
    // ğŸ”´ RED: ã‚«ãƒ©ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°å¤±æ•—ãƒ†ã‚¹ãƒˆ
    func testScoreToColorMapping() {
        XCTAssertEqual(HealthStatusCalculator.getMode(for: 85), .optimal) // ğŸ”´ FAIL: getModeæœªå®Ÿè£…
        XCTAssertEqual(HealthStatusCalculator.getMode(for: 65), .standard)
        XCTAssertEqual(HealthStatusCalculator.getMode(for: 45), .care)
        XCTAssertEqual(HealthStatusCalculator.getMode(for: 25), .rest)
    }
}
```

#### 2.2 GREENæ®µéš: æœ€å°å®Ÿè£…

```swift
// ios/TempoAI/TempoAI/Services/HealthStatusCalculator.swift
class HealthStatusCalculator {
    
    // ğŸŸ¢ GREEN: åŸºæœ¬è¨ˆç®—å®Ÿè£…
    static func calculateScore(from healthData: HealthData) -> Int {
        let heartRateScore = normalizeHeartRate(healthData.heartRate)
        let sleepScore = normalizeSleep(healthData.sleepDuration)
        let activityScore = normalizeActivity(healthData.stepCount)
        
        return Int((heartRateScore + sleepScore + activityScore) / 3 * 100)
    }
    
    static func getMode(for score: Int) -> HealthStatusMode {
        switch score {
        case 80...100: return .optimal
        case 60...79: return .standard
        case 40...59: return .care
        default: return .rest
        }
    }
    
    // ğŸŸ¢ GREEN: åŸºæœ¬æ­£è¦åŒ–é–¢æ•°
    private static func normalizeHeartRate(_ rate: Double) -> Double {
        return min(max(rate / 100.0, 0.0), 1.0)
    }
    
    private static func normalizeSleep(_ hours: Double) -> Double {
        return min(max(hours / 8.0, 0.0), 1.0)
    }
    
    private static func normalizeActivity(_ steps: Int) -> Double {
        return min(max(Double(steps) / 10000.0, 0.0), 1.0)
    }
}
```

#### 2.3 BLUEæ®µéš: ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

```swift
// ios/TempoAI/TempoAI/Services/HealthStatusCalculator.swift - æ‹¡å¼µç‰ˆ
class HealthStatusCalculator {
    
    // ğŸ”µ BLUE: é‡ã¿ä»˜ã‘è¨ˆç®—ã«æ‹¡å¼µ
    static func calculateScore(from healthData: HealthData) -> Int {
        let weights = HealthMetricWeights.default
        let metrics = HealthMetrics(from: healthData)
        
        let weightedScore = (
            metrics.heartRateScore * weights.heartRate +
            metrics.sleepScore * weights.sleep +
            metrics.activityScore * weights.activity +
            metrics.hrVariabilityScore * weights.hrVariability
        )
        
        return Int(weightedScore * 100).clamped(to: 0...100)
    }
    
    // ğŸ”µ BLUE: è©³ç´°èª¬æ˜ç”Ÿæˆ
    static func generateStatusDescription(mode: HealthStatusMode, data: HealthData, language: Language) -> String {
        let localizationKey = "health_status_\(mode.rawValue)_description"
        return NSLocalizedString(localizationKey, comment: "Health status description")
    }
    
    // ğŸ”µ BLUE: ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æè¿½åŠ 
    static func calculateTrend(current: HealthData, previous: [HealthData]) -> HealthTrend {
        guard !previous.isEmpty else { return .stable }
        
        let currentScore = calculateScore(from: current)
        let averagePreviousScore = previous
            .map(calculateScore)
            .reduce(0, +) / previous.count
        
        let difference = currentScore - averagePreviousScore
        
        switch difference {
        case 10...: return .improving
        case -10..<0: return .declining
        default: return .stable
        }
    }
}
```

### 3. å¤©æ°—å¯¾å¿œæŒ¨æ‹¶TDD

#### 3.1 REDæ®µéš: æŒ¨æ‹¶ç”Ÿæˆå¤±æ•—ãƒ†ã‚¹ãƒˆ

```swift
// ios/TempoAI/TempoAITests/Services/GreetingServiceTests.swift
class GreetingServiceTests: XCTestCase {
    
    // ğŸ”´ RED: æ™‚é–“å¸¯åˆ¥æŒ¨æ‹¶å¤±æ•—ãƒ†ã‚¹ãƒˆ
    func testTimeBasedGreeting() {
        let morningTime = Calendar.current.date(bySettingHour: 8, minute: 0, second: 0, of: Date())!
        let greeting = GreetingService.generateGreeting(
            weather: MockWeather.sunny,
            time: morningTime,
            userName: "ç”°ä¸­",
            language: .japanese
        )
        
        XCTAssertTrue(greeting.contains("ãŠã¯ã‚ˆã†")) // ğŸ”´ FAIL: generateGreetingæœªå®Ÿè£…
        XCTAssertTrue(greeting.contains("ç”°ä¸­"))
    }
    
    // ğŸ”´ RED: å¤©æ°—é€£å‹•æŒ¨æ‹¶å¤±æ•—ãƒ†ã‚¹ãƒˆ
    func testWeatherBasedGreeting() {
        let rainyWeather = Weather(condition: .rainy, temperature: 20.0, humidity: 80.0)
        let greeting = GreetingService.generateGreeting(
            weather: rainyWeather,
            time: Date(),
            userName: "ä½è—¤",
            language: .japanese
        )
        
        XCTAssertTrue(greeting.contains("é›¨")) // ğŸ”´ FAIL: å¤©æ°—æ¡ä»¶åæ˜ æœªå®Ÿè£…
    }
}
```

#### 3.2 GREENæ®µéš: åŸºæœ¬å®Ÿè£…

```swift
// ios/TempoAI/TempoAI/Services/GreetingService.swift
struct GreetingService {
    
    // ğŸŸ¢ GREEN: åŸºæœ¬æŒ¨æ‹¶ç”Ÿæˆ
    static func generateGreeting(
        weather: Weather,
        time: Date,
        userName: String?,
        language: Language
    ) -> String {
        let timeOfDay = getTimeOfDay(time)
        let weatherCondition = weather.condition
        
        switch language {
        case .japanese:
            return generateJapaneseGreeting(timeOfDay: timeOfDay, weather: weatherCondition, userName: userName)
        case .english:
            return generateEnglishGreeting(timeOfDay: timeOfDay, weather: weatherCondition, userName: userName)
        }
    }
    
    private static func generateJapaneseGreeting(timeOfDay: TimeOfDay, weather: WeatherCondition, userName: String?) -> String {
        let timeGreeting = getJapaneseTimeGreeting(timeOfDay)
        let weatherComment = getJapaneseWeatherComment(weather)
        let name = userName ?? "ã•ã‚“"
        
        return "\(timeGreeting)ã€\(name)ã•ã‚“ã€‚\(weatherComment)"
    }
    
    private static func getJapaneseTimeGreeting(_ timeOfDay: TimeOfDay) -> String {
        switch timeOfDay {
        case .morning: return "ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™"
        case .afternoon: return "ã“ã‚“ã«ã¡ã¯"
        case .evening: return "ã“ã‚“ã°ã‚“ã¯"
        }
    }
    
    private static func getJapaneseWeatherComment(_ weather: WeatherCondition) -> String {
        switch weather {
        case .sunny: return "ä»Šæ—¥ã¯è‰¯ã„å¤©æ°—ã§ã™ã­"
        case .rainy: return "é›¨ã®æ—¥ã§ã™ãŒä½“èª¿ç®¡ç†ã‚’ã—ã£ã‹ã‚Šã¨"
        case .cloudy: return "æ›‡ã‚Šç©ºã§ã™ãŒå…ƒæ°—ã«ã„ãã¾ã—ã‚‡ã†"
        case .snowy: return "é›ªã®æ—¥ã¯æš–ã‹ãã—ã¦ãã ã•ã„"
        }
    }
}
```

#### 3.3 BLUEæ®µéš: ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

```swift
// ios/TempoAI/TempoAI/Services/GreetingService.swift - æ‹¡å¼µç‰ˆ
struct GreetingService {
    
    // ğŸ”µ BLUE: ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³å¼·åŒ–
    static func generateGreeting(
        weather: Weather,
        time: Date,
        userName: String?,
        language: Language,
        userProfile: UserProfile? = nil,
        healthStatus: HealthStatusMode? = nil
    ) -> String {
        
        let context = GreetingContext(
            timeOfDay: getTimeOfDay(time),
            weather: weather,
            userName: userName,
            userProfile: userProfile,
            healthStatus: healthStatus,
            language: language
        )
        
        return GreetingGenerator.generate(from: context)
    }
}

// ğŸ”µ BLUE: å°‚ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæ§‹é€ ä½“
struct GreetingContext {
    let timeOfDay: TimeOfDay
    let weather: Weather
    let userName: String?
    let userProfile: UserProfile?
    let healthStatus: HealthStatusMode?
    let language: Language
}

// ğŸ”µ BLUE: ç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³åˆ†é›¢
struct GreetingGenerator {
    static func generate(from context: GreetingContext) -> String {
        switch context.language {
        case .japanese:
            return JapaneseGreetingGenerator.generate(from: context)
        case .english:
            return EnglishGreetingGenerator.generate(from: context)
        }
    }
}

// ğŸ”µ BLUE: æ—¥æœ¬èªç‰¹åŒ–ç”Ÿæˆå™¨
struct JapaneseGreetingGenerator {
    static func generate(from context: GreetingContext) -> String {
        let components = [
            timeComponent(context),
            nameComponent(context),
            weatherComponent(context),
            healthComponent(context)
        ].compactMap { $0 }
        
        return components.joined(separator: "ã€‚")
    }
    
    private static func timeComponent(_ context: GreetingContext) -> String {
        switch context.timeOfDay {
        case .morning: return "ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™"
        case .afternoon: return "ã“ã‚“ã«ã¡ã¯"
        case .evening: return "ãŠç–²ã‚Œæ§˜ã§ã™"
        }
    }
    
    private static func nameComponent(_ context: GreetingContext) -> String? {
        guard let name = context.userName else { return nil }
        return "\(name)ã•ã‚“"
    }
    
    private static func weatherComponent(_ context: GreetingContext) -> String {
        let temperature = context.weather.temperature
        let condition = context.weather.condition
        
        switch condition {
        case .sunny:
            return temperature > 25 ? "æš‘ã„æ—¥ã«ãªã‚Šãã†ã§ã™ã­" : "è‰¯ã„ãŠå¤©æ°—ã§ã™ã­"
        case .rainy:
            return "é›¨ã®æ—¥ã§ã™ãŒã€ä½“èª¿ç®¡ç†ã‚’ã—ã£ã‹ã‚Šã¨"
        case .cloudy:
            return "æ›‡ã‚Šç©ºã§ã™ãŒã€å…ƒæ°—ã«ã„ãã¾ã—ã‚‡ã†"
        case .snowy:
            return "é›ªã®æ—¥ã¯æš–ã‹ãã—ã¦ãã ã•ã„"
        }
    }
    
    private static func healthComponent(_ context: GreetingContext) -> String? {
        guard let status = context.healthStatus else { return nil }
        
        switch status {
        case .optimal:
            return "ä»Šæ—¥ã‚‚çµ¶å¥½èª¿ã§ã™ã­"
        case .standard:
            return "ä½“èª¿ã¯è‰¯å¥½ã®ã‚ˆã†ã§ã™ã­"
        case .care:
            return "å°‘ã—æ°—ã‚’ã¤ã‘ã¦éã”ã—ã¾ã—ã‚‡ã†"
        case .rest:
            return "ä»Šæ—¥ã¯ã‚†ã£ãã‚Šä¼‘ã‚€ã“ã¨ã‚’å¿ƒãŒã‘ã¦"
        }
    }
}
```

### TDDå“è³ªç®¡ç†æŒ‡æ¨™

#### ã‚µã‚¤ã‚¯ãƒ«å®Œäº†åŸºæº–

**REDæ®µéšå®Œäº†**:
- [ ] ãƒ†ã‚¹ãƒˆãŒäºˆæƒ³é€šã‚Šã«å¤±æ•—ã™ã‚‹
- [ ] å¤±æ•—ç†ç”±ãŒæ˜ç¢ºï¼ˆã€Œæœªå®Ÿè£…ã€ã€Œãƒ­ã‚¸ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ã€ç­‰ï¼‰
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæœ‰æ„å‘³

**GREENæ®µéšå®Œäº†**:
- [ ] å…¨ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] å®Ÿè£…ãŒæœ€å°é™ï¼ˆä½™è¨ˆãªæ©Ÿèƒ½ãªã—ï¼‰
- [ ] ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãªã—

**BLUEæ®µéšå®Œäº†**:
- [ ] ã‚³ãƒ¼ãƒ‰å“è³ªãŒå‘ä¸Šï¼ˆå¯èª­æ€§ãƒ»ä¿å®ˆæ€§ï¼‰
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒè¨±å®¹ç¯„å›²å†…
- [ ] ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ‘ã‚¿ãƒ¼ãƒ³ã«æº–æ‹ 
- [ ] CLAUDE.md ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„æº–æ‹ 

**VERIFYæ®µéšå®Œäº†**:
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹
- [ ] UIãƒ†ã‚¹ãƒˆãŒå®‰å®šã—ã¦å‹•ä½œ
- [ ] ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ã‚·ãƒŠãƒªã‚ªãŒæˆåŠŸ
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ãŒåŸºæº–å†…

#### é€±é–“TDDæŒ‡æ¨™

| æŒ‡æ¨™ | Phase 1ç›®æ¨™ | æ¸¬å®šæ–¹æ³• |
|------|-------------|----------|
| **ã‚µã‚¤ã‚¯ãƒ«å®Œäº†æ•°** | 30ã‚µã‚¤ã‚¯ãƒ«/é€± | Git commitæ•°ãƒ™ãƒ¼ã‚¹ |
| **REDâ†’GREENæ™‚é–“** | å¹³å‡15åˆ†ä»¥å†… | ã‚¿ã‚¤ãƒ ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚° |
| **BLUEå“è³ªå‘ä¸Š** | 100%å®Ÿæ–½ | ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ç¢ºèª |
| **VERIFYæˆåŠŸç‡** | 95%ä»¥ä¸Š | CI/CDçµæœåˆ†æ |
| **ç´¯ç©ãƒ†ã‚¹ãƒˆæ•°** | 150+ãƒ†ã‚¹ãƒˆ | ãƒ†ã‚¹ãƒˆå®Ÿè¡Œçµæœ |

---

## ğŸ§ª å®Œå…¨TDDå®Ÿè£…æˆ¦ç•¥

### Phase 1 TDDå®Ÿè£…ãƒãƒˆãƒªã‚¯ã‚¹

| æ©Ÿèƒ½ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | Unit Tests | Integration Tests | UI Tests | E2E Tests |
|------------------|------------|-------------------|----------|-----------|
| **OnboardingFlow** | ViewModelçŠ¶æ…‹ç®¡ç† | PermissionFlow | ãƒšãƒ¼ã‚¸é·ç§»ãƒ»è¨€èªåˆ‡æ›¿ | å®Œå…¨ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚° |
| **HealthStatus** | è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ãƒ»é–¾å€¤ | APIãƒ‡ãƒ¼ã‚¿çµ±åˆ | ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºãƒ»è‰²å¤‰æ›´ | ãƒ‡ãƒ¼ã‚¿å–å¾—â†’è¡¨ç¤º |
| **Greetings** | æŒ¨æ‹¶ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ | å¤©æ°—APIçµ±åˆ | å‹•çš„æŒ¨æ‹¶è¡¨ç¤º | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–° |
| **Environmental** | ã‚¢ãƒ©ãƒ¼ãƒˆåˆ¤å®š | å¤–éƒ¨APIçµ±åˆ | ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤ºãƒ»ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ | ç’°å¢ƒå¤‰åŒ–å¯¾å¿œ |
| **Localization** | ã‚­ãƒ¼å­˜åœ¨ãƒ»è‡ªç„¶æ€§ | è¨€èªåˆ‡æ›¿ãƒ•ãƒ­ãƒ¼ | UIè¡¨ç¤ºç¢ºèª | ã‚¯ãƒ­ã‚¹è¨€èªä½“é¨“ |

### Unit Test å®Œå…¨å®Ÿè£…ä¾‹

#### 1. HealthStatusCalculator å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆ

```swift
// ios/TempoAI/TempoAITests/Services/HealthStatusCalculatorTests.swift
class HealthStatusCalculatorTests: XCTestCase {
    
    // MARK: - ğŸ”´ RED Phase Tests
    
    func testScoreBoundaryValues() {
        // å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿
        let testCases = [
            // ã‚¹ã‚³ã‚¢, æœŸå¾…ã•ã‚Œã‚‹ãƒ¢ãƒ¼ãƒ‰
            (0, HealthStatusMode.rest),
            (39, HealthStatusMode.rest),
            (40, HealthStatusMode.care),
            (59, HealthStatusMode.care),
            (60, HealthStatusMode.standard),
            (79, HealthStatusMode.standard),
            (80, HealthStatusMode.optimal),
            (100, HealthStatusMode.optimal)
        ]
        
        for (score, expectedMode) in testCases {
            let mockData = createMockHealthData(targetScore: score)
            let calculatedMode = HealthStatusCalculator.calculateMode(from: mockData)
            
            XCTAssertEqual(calculatedMode, expectedMode,
                          "Score \(score) should map to \(expectedMode), got \(calculatedMode)")
        }
    }
    
    func testWeightedScoreCalculation() {
        // é‡ã¿ä»˜ã‘è¨ˆç®—ã®ç²¾åº¦ãƒ†ã‚¹ãƒˆ
        let perfectHealth = HealthData(
            heartRate: HeartRateData(resting: 60, average: 70, max: 180, min: 50),
            sleep: SleepData(duration: 8.0, efficiency: 95.0, deep: 2.0, rem: 1.5),
            activity: ActivityData(steps: 10000, activeMinutes: 60, calories: 2500),
            hrv: HRVData(average: 45.0, min: 35.0, max: 55.0)
        )
        
        let score = HealthStatusCalculator.calculateScore(from: perfectHealth)
        XCTAssertGreaterThanOrEqual(score, 90, "Perfect health data should score 90+")
        XCTAssertLessThanOrEqual(score, 100, "Score should not exceed 100")
    }
    
    func testEdgeCaseInputs() {
        // æ¥µç«¯ãªå€¤ã®å‡¦ç†ãƒ†ã‚¹ãƒˆ
        let extremeData = HealthData(
            heartRate: HeartRateData(resting: 200, average: 250, max: 300, min: 10),
            sleep: SleepData(duration: 0.0, efficiency: 0.0, deep: 0.0, rem: 0.0),
            activity: ActivityData(steps: 0, activeMinutes: 0, calories: 0),
            hrv: HRVData(average: 0.0, min: 0.0, max: 0.0)
        )
        
        let score = HealthStatusCalculator.calculateScore(from: extremeData)
        XCTAssertGreaterThanOrEqual(score, 0, "Score should not be negative")
        XCTAssertLessThanOrEqual(score, 100, "Score should not exceed 100")
        
        let mode = HealthStatusCalculator.calculateMode(from: extremeData)
        XCTAssertEqual(mode, .rest, "Extreme poor data should result in rest mode")
    }
    
    // MARK: - ğŸŸ¢ GREEN Phase Helper Methods
    
    private func createMockHealthData(targetScore: Int) -> HealthData {
        // ã‚¹ã‚³ã‚¢ã‹ã‚‰é€†ç®—ã—ã¦HealthDataã‚’ç”Ÿæˆ
        let normalizedScore = Double(targetScore) / 100.0
        
        return HealthData(
            heartRate: HeartRateData(
                resting: Int(60 + (normalizedScore - 0.5) * 20),
                average: 70,
                max: 180,
                min: 50
            ),
            sleep: SleepData(
                duration: 5.0 + (normalizedScore * 3.0),
                efficiency: 60.0 + (normalizedScore * 35.0),
                deep: 1.0 + (normalizedScore * 1.0),
                rem: 0.5 + (normalizedScore * 1.0)
            ),
            activity: ActivityData(
                steps: Int(3000 + (normalizedScore * 7000)),
                activeMinutes: Int(20 + (normalizedScore * 40)),
                calories: Int(1800 + (normalizedScore * 700))
            ),
            hrv: HRVData(
                average: 25.0 + (normalizedScore * 25.0),
                min: 15.0 + (normalizedScore * 20.0),
                max: 35.0 + (normalizedScore * 30.0)
            )
        )
    }
}
```

#### 2. GreetingService å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ

```swift
// ios/TempoAI/TempoAITests/Services/GreetingServiceTests.swift
class GreetingServiceTests: XCTestCase {
    
    // MARK: - ğŸ”´ RED Phase: æŒ¨æ‹¶ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ
    
    func testAllWeatherTimePatterns() {
        let testCases: [(WeatherCondition, TimeOfDay, Language, String)] = [
            (.sunny, .morning, .japanese, "ãŠã¯ã‚ˆã†"),
            (.rainy, .afternoon, .japanese, "é›¨"),
            (.snowy, .evening, .japanese, "é›ª"),
            (.sunny, .morning, .english, "Beautiful"),
            (.cloudy, .afternoon, .english, "Cloudy"),
        ]
        
        for (weather, time, language, expectedKeyword) in testCases {
            let greeting = GreetingService.generateGreeting(
                weather: createMockWeather(condition: weather),
                time: createMockTime(for: time),
                userName: "ãƒ†ã‚¹ãƒˆ",
                language: language
            )
            
            XCTAssertTrue(greeting.contains(expectedKeyword),
                         "Greeting '\(greeting)' should contain '\(expectedKeyword)'")
        }
    }
    
    func testPersonalizationWithName() {
        let greetingWithName = GreetingService.generateGreeting(
            weather: createMockWeather(condition: .sunny),
            time: createMockTime(for: .morning),
            userName: "ç”°ä¸­",
            language: .japanese
        )
        
        let greetingWithoutName = GreetingService.generateGreeting(
            weather: createMockWeather(condition: .sunny),
            time: createMockTime(for: .morning),
            userName: nil,
            language: .japanese
        )
        
        XCTAssertTrue(greetingWithName.contains("ç”°ä¸­"),
                     "Greeting should include user name when provided")
        XCTAssertFalse(greetingWithoutName.contains("ç”°ä¸­"),
                      "Greeting should not include name when not provided")
    }
    
    func testTemperatureAdaptation() {
        let hotWeather = createMockWeather(condition: .sunny, temperature: 35.0)
        let coldWeather = createMockWeather(condition: .cloudy, temperature: -5.0)
        
        let hotGreeting = GreetingService.generateGreeting(
            weather: hotWeather,
            time: createMockTime(for: .morning),
            userName: nil,
            language: .japanese
        )
        
        let coldGreeting = GreetingService.generateGreeting(
            weather: coldWeather,
            time: createMockTime(for: .morning),
            userName: nil,
            language: .japanese
        )
        
        XCTAssertTrue(hotGreeting.contains("æš‘ã„") || hotGreeting.contains("ç†±ä¸­ç—‡"),
                     "Hot weather greeting should mention heat")
        XCTAssertTrue(coldGreeting.contains("å¯’ã„") || coldGreeting.contains("é˜²å¯’"),
                     "Cold weather greeting should mention cold")
    }
    
    func testJapaneseNaturalnessPatterns() {
        // æ—¥æœ¬èªã®è‡ªç„¶æ€§ãƒ†ã‚¹ãƒˆ
        let greeting = GreetingService.generateGreeting(
            weather: createMockWeather(condition: .sunny),
            time: createMockTime(for: .morning),
            userName: "å±±ç”°",
            language: .japanese
        )
        
        // ä¸è‡ªç„¶ãªè¡¨ç¾ã®æ¤œå‡º
        let unnaturalPatterns = [
            "ã‚ãªãŸã®å±±ç”°", // é‡è¤‡ã—ãŸã€Œã‚ãªãŸã®ã€
            "ã§ã™ã€‚ã§ã™ã€‚", // é‡è¤‡ã—ãŸèªå°¾
            "ã¦ãã ã•ã„ã€‚ãã ã•ã„ã€‚", // é‡è¤‡ã—ãŸæ•¬èª
        ]
        
        for pattern in unnaturalPatterns {
            XCTAssertFalse(greeting.contains(pattern),
                          "Japanese greeting should not contain unnatural pattern: \(pattern)")
        }
        
        // è‡ªç„¶ãªè¡¨ç¾ã®ç¢ºèª
        let naturalPatterns = [
            "ã•ã‚“",      // é©åˆ‡ãªæ•¬èª
            "ã”ã–ã„ã¾ã™", // ä¸å¯§èª
            "ã§ã™ã­",     // è‡ªç„¶ãªèªå°¾
        ]
        
        let hasNaturalPattern = naturalPatterns.contains { greeting.contains($0) }
        XCTAssertTrue(hasNaturalPattern, "Japanese greeting should contain natural expressions")
    }
    
    // MARK: - ğŸŸ¢ GREEN Phase Helper Methods
    
    private func createMockWeather(condition: WeatherCondition, temperature: Double = 20.0) -> WeatherData {
        return WeatherData(
            condition: condition,
            temperature: temperature,
            humidity: 60.0,
            pressure: 1013.25,
            uvIndex: 5.0
        )
    }
    
    private func createMockTime(for timeOfDay: TimeOfDay) -> Date {
        let calendar = Calendar.current
        let now = Date()
        
        let hour: Int
        switch timeOfDay {
        case .morning: hour = 8
        case .afternoon: hour = 14
        case .evening: hour = 19
        }
        
        return calendar.date(bySettingHour: hour, minute: 0, second: 0, of: now) ?? now
    }
}
```

### Integration Test å®Œå…¨å®Ÿè£…ä¾‹

#### 1. HomeViewModel çµ±åˆãƒ†ã‚¹ãƒˆ

```swift
// ios/TempoAI/TempoAITests/ViewModels/HomeViewModelIntegrationTests.swift
class HomeViewModelIntegrationTests: XCTestCase {
    
    var sut: HomeViewModel!
    var mockHealthKitManager: MockHealthKitManager!
    var mockAPIClient: MockAPIClient!
    var mockCacheManager: MockCacheManager!
    
    override func setUp() async throws {
        try await super.setUp()
        
        // Mock dependencies setup
        mockHealthKitManager = MockHealthKitManager()
        mockAPIClient = MockAPIClient()
        mockCacheManager = MockCacheManager()
        
        sut = HomeViewModel(
            healthKitManager: mockHealthKitManager,
            apiClient: mockAPIClient,
            cacheManager: mockCacheManager
        )
    }
    
    // MARK: - ğŸ”´ RED Phase: Integration Scenarios
    
    func testCompleteDataLoadingFlow() async throws {
        // Given: Mock data setup
        let mockHealthData = createMockHealthData()
        let mockWeather = createMockWeatherData()
        let mockAdvice = createMockDailyAdvice()
        
        mockHealthKitManager.mockHealthData = mockHealthData
        mockAPIClient.mockWeatherData = mockWeather
        mockAPIClient.mockAdvice = mockAdvice
        
        // When: Load initial data
        await sut.loadInitialData()
        
        // Then: All data should be loaded
        XCTAssertFalse(sut.isLoading, "Loading should complete")
        XCTAssertNotNil(sut.healthStatus, "Health status should be calculated")
        XCTAssertNotNil(sut.todayAdvice, "Today's advice should be loaded")
        XCTAssertTrue(sut.environmentalAlerts.isEmpty || !sut.environmentalAlerts.isEmpty,
                     "Environmental alerts should be processed")
        XCTAssertNil(sut.errorMessage, "No error should occur")
    }
    
    func testErrorRecoveryFlow() async throws {
        // Given: Health data succeeds, API fails
        let mockHealthData = createMockHealthData()
        mockHealthKitManager.mockHealthData = mockHealthData
        mockAPIClient.shouldFail = true
        
        // When: Load initial data
        await sut.loadInitialData()
        
        // Then: Partial success with fallback
        XCTAssertNotNil(sut.healthStatus, "Health status should be available from local data")
        XCTAssertNotNil(sut.errorMessage, "Error should be reported")
        XCTAssertTrue(sut.errorMessage!.contains("ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯") || 
                      sut.errorMessage!.contains("network"), "Error should mention network issue")
    }
    
    func testCacheHitFlow() async throws {
        // Given: Cache has valid data
        let cachedAdvice = createMockDailyAdvice()
        mockCacheManager.setCachedData(cachedAdvice, forKey: "daily_advice")
        
        // When: Load initial data
        await sut.loadInitialData()
        
        // Then: Should use cached data
        XCTAssertEqual(mockAPIClient.requestCount, 0, "Should not make API request when cache hit")
        XCTAssertNotNil(sut.todayAdvice, "Cached advice should be loaded")
    }
    
    func testLanguageChangeFlow() async throws {
        // Given: Initial data loaded
        await sut.loadInitialData()
        let initialGreeting = sut.personalizedGreeting
        
        // When: Language changes
        LocalizationManager.shared.setLanguage(.english)
        await sut.refreshLocalizedContent()
        
        // Then: Greeting should update
        XCTAssertNotEqual(sut.personalizedGreeting, initialGreeting,
                         "Greeting should change with language")
        XCTAssertFalse(sut.personalizedGreeting.contains("ã•ã‚“"),
                      "English greeting should not contain Japanese honorifics")
    }
}

// MARK: - Mock Classes

class MockHealthKitManager: HealthKitManagerProtocol {
    var mockHealthData: HealthData?
    var shouldFail: Bool = false
    
    func fetchTodayHealthData() async throws -> HealthData {
        if shouldFail {
            throw HealthKitError.dataUnavailable
        }
        return mockHealthData ?? HealthData.defaultMock
    }
}

class MockAPIClient: APIClientProtocol {
    var mockWeatherData: WeatherData?
    var mockAdvice: DailyAdvice?
    var shouldFail: Bool = false
    var requestCount: Int = 0
    
    func fetchWeather(for location: LocationData) async throws -> WeatherData {
        requestCount += 1
        if shouldFail {
            throw APIError.networkError
        }
        return mockWeatherData ?? WeatherData.defaultMock
    }
    
    func generateAdvice(_ request: AdviceRequest) async throws -> DailyAdvice {
        requestCount += 1
        if shouldFail {
            throw APIError.serviceUnavailable
        }
        return mockAdvice ?? DailyAdvice.defaultMock
    }
}
```

### UI Test å®Œå…¨å®Ÿè£…ä¾‹

#### 1. ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼ UIãƒ†ã‚¹ãƒˆ

```swift
// ios/TempoAI/TempoAIUITests/OnboardingUITestsComplete.swift
class OnboardingUITestsComplete: XCTestCase {
    
    var app: XCUIApplication!
    
    override func setUp() {
        super.setUp()
        continueAfterFailure = false
        
        app = XCUIApplication()
        app.launchEnvironment["RESET_ONBOARDING"] = "true"
        app.launchEnvironment["MOCK_HEALTHKIT"] = "true"
        app.launch()
    }
    
    // MARK: - Complete Onboarding Flow Tests
    
    func testCompleteOnboardingFlowJapanese() throws {
        // Page 1: Welcome
        let welcomeTitle = app.staticTexts["Tempo AI ã¸ã‚ˆã†ã“ã"]
        XCTAssertTrue(welcomeTitle.waitForExistence(timeout: 5))
        
        let nextButton = app.buttons["æ¬¡ã¸"]
        XCTAssertTrue(nextButton.exists)
        nextButton.tap()
        
        // Page 2: Data Integration
        let dataTitle = app.staticTexts["3ã¤ã®ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆ"]
        XCTAssertTrue(dataTitle.waitForExistence(timeout: 2))
        
        // ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹è¦ç´ ã®ç¢ºèª
        XCTAssertTrue(app.staticTexts["ã‚ãªãŸã®ä½“ã®çŠ¶æ…‹"].exists)
        XCTAssertTrue(app.staticTexts["ä»Šæ—¥ã®ç’°å¢ƒ"].exists)
        XCTAssertTrue(app.staticTexts["æ˜¨æ—¥ã®éã”ã—æ–¹"].exists)
        
        app.buttons["æ¬¡ã¸"].tap()
        
        // Page 3: AI Analysis
        let analysisTitle = app.staticTexts["AIãŒåˆ†æã™ã‚‹ã“ã¨"]
        XCTAssertTrue(analysisTitle.waitForExistence(timeout: 2))
        app.buttons["æ¬¡ã¸"].tap()
        
        // Page 4: Get Started + Permissions
        let startTitle = app.staticTexts["æ¯æœå±Šãã‚‚ã®"]
        XCTAssertTrue(startTitle.waitForExistence(timeout: 2))
        
        let startButton = app.buttons["å§‹ã‚ã‚‹"]
        XCTAssertTrue(startButton.exists)
        startButton.tap()
        
        // Permission flow
        handlePermissionRequests()
        
        // Verify completion - should navigate to main app
        let homeTab = app.buttons["ä»Šæ—¥"]
        XCTAssertTrue(homeTab.waitForExistence(timeout: 10))
    }
    
    func testLanguageSwitchingDuringOnboarding() throws {
        // Start in Japanese
        XCTAssertTrue(app.staticTexts["Tempo AI ã¸ã‚ˆã†ã“ã"].waitForExistence(timeout: 5))
        
        // Switch to English
        let languageButton = app.buttons["language_settings"]
        XCTAssertTrue(languageButton.exists)
        languageButton.tap()
        
        let englishOption = app.buttons["English"]
        XCTAssertTrue(englishOption.waitForExistence(timeout: 2))
        englishOption.tap()
        
        // Verify language change
        let englishTitle = app.staticTexts["Welcome to Tempo AI"]
        XCTAssertTrue(englishTitle.waitForExistence(timeout: 3))
        
        // Continue onboarding in English
        app.buttons["Next"].tap()
        XCTAssertTrue(app.staticTexts["3 Types of Data"].waitForExistence(timeout: 2))
        
        // Switch back to Japanese
        app.buttons["language_settings"].tap()
        app.buttons["æ—¥æœ¬èª"].tap()
        
        // Verify language switched back
        XCTAssertTrue(app.staticTexts["3ã¤ã®ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆ"].waitForExistence(timeout: 2))
    }
    
    func testSkipFunctionality() throws {
        XCTAssertTrue(app.staticTexts["Tempo AI ã¸ã‚ˆã†ã“ã"].waitForExistence(timeout: 5))
        
        // Test skip button
        let skipButton = app.buttons["ã‚¹ã‚­ãƒƒãƒ—"]
        XCTAssertTrue(skipButton.exists)
        skipButton.tap()
        
        // Should show confirmation alert
        let alert = app.alerts.firstMatch
        XCTAssertTrue(alert.waitForExistence(timeout: 2))
        XCTAssertTrue(app.staticTexts["ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã‹ï¼Ÿ"].exists)
        
        // Confirm skip
        app.buttons["ã¯ã„"].tap()
        
        // Should go to permission requests
        handlePermissionRequests()
        
        // Should reach main app
        let homeTab = app.buttons["ä»Šæ—¥"]
        XCTAssertTrue(homeTab.waitForExistence(timeout: 10))
    }
    
    func testPermissionFlowRecovery() throws {
        // Complete onboarding to permission phase
        navigateToPermissions()
        
        // Deny HealthKit permission
        let healthKitPermission = app.buttons["HealthKitè¨±å¯"]
        healthKitPermission.tap()
        
        // Handle system permission dialog - deny
        let springboard = XCUIApplication(bundleIdentifier: "com.apple.springboard")
        let denyButton = springboard.buttons["Don't Allow"]
        if denyButton.waitForExistence(timeout: 5) {
            denyButton.tap()
        }
        
        // App should show fallback options
        let fallbackMessage = app.staticTexts["ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã§ä½“é¨“ã§ãã¾ã™"]
        XCTAssertTrue(fallbackMessage.waitForExistence(timeout: 5))
        
        let demoButton = app.buttons["ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã§ç¶šã‘ã‚‹"]
        XCTAssertTrue(demoButton.exists)
        demoButton.tap()
        
        // Should still reach main app in demo mode
        let homeTab = app.buttons["ä»Šæ—¥"]
        XCTAssertTrue(homeTab.waitForExistence(timeout: 10))
        
        // Verify demo mode indicator
        XCTAssertTrue(app.staticTexts["ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰"].exists)
    }
    
    // MARK: - Helper Methods
    
    private func navigateToPermissions() {
        // Navigate through all onboarding pages to permissions
        XCTAssertTrue(app.staticTexts["Tempo AI ã¸ã‚ˆã†ã“ã"].waitForExistence(timeout: 5))
        
        for _ in 0..<3 {
            app.buttons["æ¬¡ã¸"].tap()
            Thread.sleep(forTimeInterval: 0.5)
        }
        
        app.buttons["å§‹ã‚ã‚‹"].tap()
    }
    
    private func handlePermissionRequests() {
        let springboard = XCUIApplication(bundleIdentifier: "com.apple.springboard")
        
        // Handle HealthKit permission
        let healthKitAllow = springboard.buttons["OK"]
        if healthKitAllow.waitForExistence(timeout: 5) {
            healthKitAllow.tap()
        }
        
        // Handle Location permission
        let locationAllow = springboard.buttons["Allow While Using App"]
        if locationAllow.waitForExistence(timeout: 5) {
            locationAllow.tap()
        }
        
        // Handle Notification permission
        let notificationAllow = springboard.buttons["Allow"]
        if notificationAllow.waitForExistence(timeout: 5) {
            notificationAllow.tap()
        }
    }
}
```

### End-to-End Test å®Œå…¨å®Ÿè£…ä¾‹

```swift
// ios/TempoAI/TempoAIUITests/EndToEndFlowTests.swift
class EndToEndFlowTests: XCTestCase {
    
    func testCompleteUserJourneyWithDataSync() throws {
        let app = XCUIApplication()
        app.launchEnvironment["RESET_ALL_DATA"] = "true"
        app.launchEnvironment["ENABLE_REAL_APIs"] = "true"
        app.launch()
        
        // 1. Complete Onboarding
        completeOnboardingFlow()
        
        // 2. First-time data loading
        waitForInitialDataLoad()
        
        // 3. Verify health status calculation
        verifyHealthStatusDisplay()
        
        // 4. Test weather integration
        verifyWeatherIntegration()
        
        // 5. Test language switching
        verifyLanguageSwitchingFlow()
        
        // 6. Test refresh functionality
        verifyDataRefreshFlow()
    }
    
    private func completeOnboardingFlow() {
        // Fast onboarding completion
        XCTAssertTrue(app.staticTexts["Tempo AI ã¸ã‚ˆã†ã“ã"].waitForExistence(timeout: 10))
        
        for _ in 0..<3 {
            app.buttons["æ¬¡ã¸"].tap()
            Thread.sleep(forTimeInterval: 1)
        }
        
        app.buttons["å§‹ã‚ã‚‹"].tap()
        handleAllPermissions()
    }
    
    private func waitForInitialDataLoad() {
        // Wait for main screen to load with data
        let homeTab = app.buttons["ä»Šæ—¥"]
        XCTAssertTrue(homeTab.waitForExistence(timeout: 30))
        
        // Wait for health data to load
        let loadingIndicator = app.activityIndicators["loading"]
        let loaded = NSPredicate(format: "exists == false")
        expectation(for: loaded, evaluatedWith: loadingIndicator, handler: nil)
        waitForExpectations(timeout: 30)
    }
    
    private func verifyHealthStatusDisplay() {
        // Verify health status elements
        XCTAssertTrue(app.staticTexts["ä»Šæ—¥ã®ã‚ãªãŸ"].exists)
        
        // Should have one of the status modes displayed
        let statusModes = ["æœ€é©ãƒ¢ãƒ¼ãƒ‰", "æ¨™æº–ãƒ¢ãƒ¼ãƒ‰", "ã‚±ã‚¢ãƒ¢ãƒ¼ãƒ‰", "ä¼‘æ¯ãƒ¢ãƒ¼ãƒ‰"]
        let hasStatusMode = statusModes.contains { app.staticTexts[$0].exists }
        XCTAssertTrue(hasStatusMode, "Should display a health status mode")
        
        // Should have score display
        let scoreElements = app.staticTexts.matching(NSPredicate(format: "label CONTAINS '/'"))
        XCTAssertGreaterThan(scoreElements.count, 0, "Should display health score")
    }
    
    private func verifyWeatherIntegration() {
        // Verify weather-based greeting
        let greetingElements = app.staticTexts.matching(NSPredicate(format: "label CONTAINS 'æœ' OR label CONTAINS 'å¤©æ°—' OR label CONTAINS 'æ°—æ¸©'"))
        XCTAssertGreaterThan(greetingElements.count, 0, "Should display weather-based greeting")
        
        // Verify environmental alerts if any
        let alertsSection = app.scrollViews["environmental_alerts"]
        if alertsSection.exists {
            XCTAssertTrue(app.staticTexts["ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆ"].exists)
        }
    }
    
    private func verifyLanguageSwitchingFlow() {
        // Switch to English
        app.buttons["è¨­å®š"].tap()
        app.buttons["è¨€èªè¨­å®š"].tap()
        app.buttons["English"].tap()
        
        // Verify UI updates to English
        XCTAssertTrue(app.staticTexts["Today"].waitForExistence(timeout: 5))
        XCTAssertTrue(app.staticTexts["Your Status Today"].exists)
        
        // Switch back to Japanese
        app.buttons["Language Settings"].tap()
        app.buttons["æ—¥æœ¬èª"].tap()
        
        // Verify UI updates back to Japanese
        XCTAssertTrue(app.staticTexts["ä»Šæ—¥"].waitForExistence(timeout: 5))
        XCTAssertTrue(app.staticTexts["ä»Šæ—¥ã®ã‚ãªãŸ"].exists)
    }
    
    private func verifyDataRefreshFlow() {
        // Pull to refresh
        let scrollView = app.scrollViews.firstMatch
        let start = scrollView.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.3))
        let end = scrollView.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.8))
        
        start.press(forDuration: 0.1, thenDragTo: end)
        
        // Verify refresh indicator appears
        let refreshControl = app.activityIndicators["refresh"]
        XCTAssertTrue(refreshControl.waitForExistence(timeout: 2))
        
        // Wait for refresh to complete
        let refreshComplete = NSPredicate(format: "exists == false")
        expectation(for: refreshComplete, evaluatedWith: refreshControl, handler: nil)
        waitForExpectations(timeout: 15)
    }
}

---

## ğŸ—ï¸ æŠ€è¡“å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

### SwiftUI MVVM ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è©³ç´°

#### 1. Viewå±¤å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

```swift
// Phase 1å°‚ç”¨Viewå®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
struct TempoUIView: View {
    @StateObject private var viewModel: TempoViewModel
    @StateObject private var localization = LocalizationManager.shared
    @Environment(\.colorScheme) var colorScheme
    
    init() {
        _viewModel = StateObject(wrappedValue: TempoViewModel())
    }
    
    var body: some View {
        // CLAUDE.mdæº–æ‹ ã®Viewæ§‹ç¯‰
        VStack(spacing: DesignSystem.spacing.medium) {
            headerSection
            contentSection
            footerSection
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(DesignSystem.colors.background)
        .task {
            await viewModel.loadInitialData()
        }
        .onChange(of: localization.currentLanguage) { _ in
            Task {
                await viewModel.refreshLocalizedContent()
            }
        }
    }
    
    @ViewBuilder
    private var headerSection: some View {
        // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    }
    
    @ViewBuilder
    private var contentSection: some View {
        // ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
    }
    
    @ViewBuilder
    private var footerSection: some View {
        // ãƒ•ãƒƒã‚¿ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    }
}
```

#### 2. ViewModelå±¤å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

```swift
// Phase 1 ViewModelå®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
@MainActor
class TempoViewModel: ObservableObject {
    // Published ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ï¼ˆçŠ¶æ…‹ç®¡ç†ï¼‰
    @Published var loadingState: LoadingState = .idle
    @Published var errorState: ErrorState?
    @Published var data: TempoData?
    
    // ä¾å­˜é–¢ä¿‚ï¼ˆDIï¼‰
    private let dataService: DataServiceProtocol
    private let localizationManager: LocalizationManager
    
    // CLAUDE.mdæº–æ‹ ã®åˆæœŸåŒ–
    init(
        dataService: DataServiceProtocol = DefaultDataService(),
        localizationManager: LocalizationManager = .shared
    ) {
        self.dataService = dataService
        self.localizationManager = localizationManager
    }
    
    // éåŒæœŸãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    func loadInitialData() async {
        loadingState = .loading
        
        do {
            let fetchedData = try await dataService.fetchData()
            await MainActor.run {
                self.data = fetchedData
                self.loadingState = .loaded
            }
        } catch {
            await MainActor.run {
                self.errorState = ErrorState(error: error)
                self.loadingState = .error
            }
        }
    }
    
    // è¨€èªåˆ‡ã‚Šæ›¿ãˆå¯¾å¿œ
    func refreshLocalizedContent() async {
        // ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ä¾å­˜ãƒ‡ãƒ¼ã‚¿ã®å†èª­ã¿è¾¼ã¿
    }
}
```

#### 3. Modelå±¤å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

```swift
// Phase 1 Modelå®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
struct TempoData: Codable, Equatable {
    let id: UUID
    let timestamp: Date
    let value: DataValue
    
    // CLAUDE.mdæº–æ‹ ã®åˆæœŸåŒ–
    init(value: DataValue) {
        self.id = UUID()
        self.timestamp = Date()
        self.value = value
    }
}

// ãƒ—ãƒ­ãƒˆã‚³ãƒ«æŒ‡å‘è¨­è¨ˆ
protocol DataServiceProtocol {
    func fetchData() async throws -> TempoData
}

// å…·ä½“å®Ÿè£…
class DefaultDataService: DataServiceProtocol {
    func fetchData() async throws -> TempoData {
        // APIå‘¼ã³å‡ºã—å®Ÿè£…
    }
}
```

### Hono API è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³

#### 1. ãƒ«ãƒ¼ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼å®Ÿè£…

```typescript
// backend/src/routes/health-status.ts - Phase 1å°‚ç”¨å®Ÿè£…
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { validator } from 'hono/validator'
import { HealthStatusCalculator } from '../services/health-status-calculator'
import { EnvironmentalAlertService } from '../services/environmental-alert'
import { GreetingGenerator } from '../services/greeting-generator'

interface Bindings {
  ANTHROPIC_API_KEY: string
  ENVIRONMENT: 'development' | 'production'
  WEATHER_API_KEY: string
}

const healthRoutes = new Hono<{ Bindings: Bindings }>()

// CORSè¨­å®šï¼ˆPhase 1è¦ä»¶ï¼‰
healthRoutes.use('/*', cors({
  origin: ['https://tempo-ai.app', 'http://localhost:3000'],
  allowMethods: ['POST', 'GET', 'OPTIONS']
}))

// ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®—ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
healthRoutes.post(
  '/status',
  validator('json', (value, c) => {
    // Zod ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…
    const result = HealthStatusRequest.safeParse(value)
    if (!result.success) {
      return c.json({ error: 'Invalid request data' }, 400)
    }
    return result.data
  }),
  async (c) => {
    try {
      const requestData = c.req.valid('json')
      
      // ä¸¦åˆ—å‡¦ç†ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
      const [healthStatus, environmentalAlerts, personalizedGreeting] = await Promise.all([
        HealthStatusCalculator.calculateStatus(requestData.healthData),
        EnvironmentalAlertService.getAlerts(requestData.location, requestData.weather),
        GreetingGenerator.generateGreeting({
          weather: requestData.weather,
          time: new Date(),
          userName: requestData.userProfile.name,
          language: requestData.language
        })
      ])
      
      return c.json({
        success: true,
        data: {
          healthStatus,
          environmentalAlerts,
          personalizedGreeting,
          timestamp: new Date().toISOString()
        }
      })
      
    } catch (error) {
      console.error('Health status calculation error:', error)
      return c.json({
        error: 'Internal server error'
      }, 500)
    }
  }
)

export { healthRoutes }
```

#### 2. ã‚µãƒ¼ãƒ“ã‚¹å±¤å®Ÿè£…

```typescript
// backend/src/services/health-status-calculator.ts
export class HealthStatusCalculator {
  static async calculateStatus(healthData: HealthData): Promise<HealthStatus> {
    // ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯
    const metrics = this.extractMetrics(healthData)
    const score = this.calculateWeightedScore(metrics)
    const mode = this.determineMode(score)
    
    return {
      score,
      mode,
      details: this.generateStatusDetails(metrics, mode),
      recommendations: await this.generateRecommendations(mode, healthData)
    }
  }
  
  private static extractMetrics(data: HealthData): HealthMetrics {
    return {
      heartRate: this.normalizeHeartRate(data.heartRate),
      sleep: this.normalizeSleep(data.sleepDuration),
      activity: this.normalizeActivity(data.stepCount),
      hrVariability: this.normalizeHRV(data.heartRateVariability)
    }
  }
  
  private static calculateWeightedScore(metrics: HealthMetrics): number {
    const weights = {
      heartRate: 0.3,
      sleep: 0.3,
      activity: 0.25,
      hrVariability: 0.15
    }
    
    return Math.round(
      metrics.heartRate * weights.heartRate * 100 +
      metrics.sleep * weights.sleep * 100 +
      metrics.activity * weights.activity * 100 +
      metrics.hrVariability * weights.hrVariability * 100
    )
  }
  
  private static determineMode(score: number): HealthStatusMode {
    if (score >= 80) return 'optimal'
    if (score >= 60) return 'standard'
    if (score >= 40) return 'care'
    return 'rest'
  }
}
```

### Claude API çµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³

#### 1. AIåˆ†æã‚µãƒ¼ãƒ“ã‚¹

```typescript
// backend/src/services/ai-analysis.ts
import Anthropic from '@anthropic-ai/sdk'

export class AIAnalysisService {
  private anthropic: Anthropic
  
  constructor(apiKey: string) {
    this.anthropic = new Anthropic({
      apiKey,
      maxRetries: 3,
    })
  }
  
  async generatePersonalizedAdvice(
    healthData: HealthData,
    weather: WeatherData,
    userProfile: UserProfile,
    language: Language
  ): Promise<DailyAdvice> {
    
    const prompt = this.buildAnalysisPrompt(healthData, weather, userProfile, language)
    
    try {
      const response = await this.anthropic.messages.create({
        model: 'claude-3-haiku-20240307',
        max_tokens: 1000,
        temperature: 0.3, // ä¸€è²«æ€§é‡è¦–
        messages: [{
          role: 'user',
          content: prompt
        }]
      })
      
      const adviceText = response.content[0].text
      return this.parseAdviceResponse(adviceText, language)
      
    } catch (error) {
      console.error('Claude API error:', error)
      throw new AIAnalysisError('Failed to generate advice', error)
    }
  }
  
  private buildAnalysisPrompt(
    health: HealthData,
    weather: WeatherData,
    profile: UserProfile,
    language: Language
  ): string {
    const languageInstruction = language === 'japanese' 
      ? 'æ—¥æœ¬èªã§è‡ªç„¶ãªè¡¨ç¾ã§å›ç­”ã—ã¦ãã ã•ã„ã€‚'
      : 'Please respond in natural English.'
    
    return `
${languageInstruction}

ã‚ãªãŸã¯ãƒ˜ãƒ«ã‚¹ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ã§ã™ã€‚ä»¥ä¸‹ã®æƒ…å ±ã‹ã‚‰ä»Šæ—¥ã®æœ€é©ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ï¼š

ã€å¥åº·ãƒ‡ãƒ¼ã‚¿ã€‘
- å¿ƒæ‹æ•°: ${health.heartRate} bpm
- ç¡çœ æ™‚é–“: ${health.sleepDuration} æ™‚é–“
- æ­©æ•°: ${health.stepCount} æ­©
- å¿ƒæ‹å¤‰å‹•: ${health.heartRateVariability}

ã€ç’°å¢ƒæƒ…å ±ã€‘
- å¤©æ°—: ${weather.condition}
- æ°—æ¸©: ${weather.temperature}Â°C
- æ¹¿åº¦: ${weather.humidity}%
- æ°—åœ§: ${weather.pressure} hPa

ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã€‘
- å¹´é½¢: ${profile.age}æ­³
- æ€§åˆ¥: ${profile.gender}
- æ´»å‹•ãƒ¬ãƒ™ãƒ«: ${profile.activityLevel}

ä»¥ä¸‹ã®å½¢å¼ã§JSONã§å›ç­”ã—ã¦ãã ã•ã„ï¼š
{
  "meal": "å…·ä½“çš„ãªé£Ÿäº‹ã‚¢ãƒ‰ãƒã‚¤ã‚¹",
  "exercise": "é‹å‹•ã‚¢ãƒ‰ãƒã‚¤ã‚¹",
  "wellness": "ç”Ÿæ´»ç¿’æ…£ã‚¢ãƒ‰ãƒã‚¤ã‚¹",
  "summary": "ä»Šæ—¥ã®ç·åˆçš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹"
}
    `
  }
  
  private parseAdviceResponse(response: string, language: Language): DailyAdvice {
    try {
      const parsed = JSON.parse(response)
      return {
        meal: parsed.meal || this.getFallbackAdvice('meal', language),
        exercise: parsed.exercise || this.getFallbackAdvice('exercise', language),
        wellness: parsed.wellness || this.getFallbackAdvice('wellness', language),
        summary: parsed.summary || this.getFallbackAdvice('summary', language),
        generatedAt: new Date().toISOString()
      }
    } catch (error) {
      console.error('Failed to parse AI response:', error)
      return this.getFallbackAdviceSet(language)
    }
  }
}
```

#### 2. ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Ÿè£…

```typescript
// backend/src/middleware/rate-limit.ts
export class RateLimitMiddleware {
  private cache = new Map<string, { count: number; resetTime: number }>()
  private readonly limit = 100 // 1æ™‚é–“ã‚ãŸã‚Š100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  private readonly windowMs = 60 * 60 * 1000 // 1æ™‚é–“
  
  middleware() {
    return async (c: Context, next: Next) => {
      const clientId = this.getClientId(c)
      const now = Date.now()
      
      // å¤ã„ã‚¨ãƒ³ãƒˆãƒªã®å‰Šé™¤
      this.cleanup(now)
      
      const entry = this.cache.get(clientId)
      
      if (!entry) {
        this.cache.set(clientId, { count: 1, resetTime: now + this.windowMs })
        return await next()
      }
      
      if (now > entry.resetTime) {
        this.cache.set(clientId, { count: 1, resetTime: now + this.windowMs })
        return await next()
      }
      
      if (entry.count >= this.limit) {
        return c.json({ error: 'Rate limit exceeded' }, 429)
      }
      
      entry.count++
      return await next()
    }
  }
}
```

---

## ğŸ”— ä¾å­˜é–¢ä¿‚ç®¡ç†ã¨å„ªå…ˆé †ä½

### Phase 1 å®Ÿè£…é †åºï¼ˆä¾å­˜é–¢ä¿‚ãƒ™ãƒ¼ã‚¹ï¼‰

```mermaid
graph TD
    A[1. ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åŸºç›¤] --> B[2. åŸºæœ¬UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ]
    A --> C[3. ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©]
    B --> D[4. ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼]
    C --> E[5. ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®—]
    C --> F[6. ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆã‚µãƒ¼ãƒ“ã‚¹]
    E --> G[7. HomeViewçµ±åˆ]
    F --> G
    D --> G
    G --> H[8. å¤©æ°—å¯¾å¿œæŒ¨æ‹¶]
    H --> I[9. çµ±åˆãƒ†ã‚¹ãƒˆ]
    I --> J[10. UI/UXãƒãƒªãƒƒã‚·ãƒ¥]
```

#### å®Ÿè£…å„ªå…ˆåº¦ãƒ¬ãƒ™ãƒ«

**P0 (Critical): å¿…é ˆåŸºç›¤è¦ç´ **

1. **ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åŸºç›¤å¼·åŒ–**
   - **ä¾å­˜**: Phase 0 å®Œäº†
   - **æœŸé–“**: 2æ—¥
   - **ç†ç”±**: å…¨UIè¦ç´ ã®å‰ææ¡ä»¶
   ```swift
   // å¿…è¦ãªãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ 
   - LocalizationManageræ‹¡å¼µï¼ˆæ—¥è‹±å®Œå…¨å¯¾å¿œï¼‰
   - Localizable.strings ãƒªã‚½ãƒ¼ã‚¹ï¼ˆ200+é …ç›®ï¼‰
   - å‹•çš„è¨€èªåˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
   - ãƒ•ã‚©ãƒ³ãƒˆãƒ»ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæœ€é©åŒ–
   ```

2. **åŸºæœ¬UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
   - **ä¾å­˜**: ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åŸºç›¤
   - **æœŸé–“**: 3æ—¥
   - **ç†ç”±**: å†åˆ©ç”¨å¯èƒ½ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç¾¤
   ```swift
   // å„ªå…ˆåº¦é †ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
   - DesignSystem (è‰²ãƒ»ãƒ•ã‚©ãƒ³ãƒˆãƒ»ã‚¹ãƒšãƒ¼ã‚·ãƒ³ã‚°)
   - LoadingIndicatorView
   - ErrorStateView
   - CardView (åŸºæœ¬ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ)
   - StatusIndicatorView
   ```

3. **ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©**
   - **ä¾å­˜**: ãªã—
   - **æœŸé–“**: 2æ—¥
   - **ç†ç”±**: APIãƒ»ãƒ­ã‚¸ãƒƒã‚¯å±¤ã®åŸºç›¤
   ```swift
   // å¿…é ˆãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
   - HealthData (æ‹¡å¼µ)
   - WeatherData (æ‹¡å¼µ)
   - EnvironmentalAlert
   - HealthStatusMode
   - UserProfile (è©³ç´°åŒ–)
   ```

**P1 (High): ã‚³ã‚¢ä½“é¨“è¦ç´ **

4. **ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼å®Ÿè£…**
   - **ä¾å­˜**: P0å®Œäº†
   - **æœŸé–“**: 4æ—¥
   - **ä¸¦åˆ—å¯èƒ½**: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIé–‹ç™ºã¨ä¸¦åˆ—
   ```swift
   // å®Ÿè£…ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
   - OnboardingView (TabViewå¼4ãƒšãƒ¼ã‚¸)
   - LanguageSelectorView
   - PermissionRequestFlow
   - OnboardingViewModel (çŠ¶æ…‹ç®¡ç†)
   ```

5. **ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³**
   - **ä¾å­˜**: ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
   - **æœŸé–“**: 3æ—¥
   - **ä¸¦åˆ—å¯èƒ½**: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£…ã¨ä¸¦åˆ—
   ```typescript
   // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Ÿè£…
   - HealthStatusCalculator (é‡ã¿ä»˜ã‘è¨ˆç®—)
   - /api/health/status ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
   - ã‚¹ã‚³ã‚¢â†’ã‚«ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ‰å¤‰æ›
   ```

6. **ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆã‚µãƒ¼ãƒ“ã‚¹**
   - **ä¾å­˜**: ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
   - **æœŸé–“**: 4æ—¥
   - **ä¸¦åˆ—å¯èƒ½**: ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨ä¸¦åˆ—
   ```typescript
   // å®Ÿè£…è¦ç´ 
   - æ°—åœ§å¤‰åŒ–æ¤œçŸ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
   - èŠ±ç²‰æƒ…å ±APIçµ±åˆ
   - AQI (å¤§æ°—è³ªæŒ‡æ•°) åˆ†æ
   - ã‚¢ãƒ©ãƒ¼ãƒˆé‡è¦åº¦åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
   ```

**P2 (Medium): ä½“é¨“å‘ä¸Šè¦ç´ **

7. **HomeViewçµ±åˆãƒ»æ´—ç·´åŒ–**
   - **ä¾å­˜**: P0, P1å®Œäº†
   - **æœŸé–“**: 3æ—¥
   - **ä¸¦åˆ—ä¸å¯**: å…¨è¦ç´ çµ±åˆãŒå¿…è¦
   ```swift
   // çµ±åˆè¦ç´ 
   - HomeViewModel (è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹çµ±åˆ)
   - PersonalizedHeaderView
   - EnvironmentalAlertsView
   - HealthStatusCardView
   - éåŒæœŸãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
   ```

8. **å¤©æ°—å¯¾å¿œãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºæŒ¨æ‹¶**
   - **ä¾å­˜**: HomeViewçµ±åˆ
   - **æœŸé–“**: 3æ—¥
   - **æ–‡åŒ–çš„é…æ…®**: æ—¥æœ¬èªè¡¨ç¾ã®è‡ªç„¶æ€§é‡è¦–
   ```swift
   // å®Ÿè£…è¦ç´ 
   - GreetingService (æ™‚é–“å¸¯ãƒ»å¤©æ°—ãƒ»å€‹äººåçµ±åˆ)
   - JapaneseGreetingPatterns (æ–‡åŒ–çš„é©å¿œ)
   - å‹•çš„æŒ¨æ‹¶æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯
   ```

**P3 (Low): å“è³ªå‘ä¸Šè¦ç´ **

9. **çµ±åˆãƒ†ã‚¹ãƒˆãƒ»å“è³ªä¿è¨¼**
   - **ä¾å­˜**: å…¨æ©Ÿèƒ½å®Ÿè£…å®Œäº†
   - **æœŸé–“**: 3æ—¥
   - **å“è³ª**: CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³çµ±åˆ
   ```swift
   // ãƒ†ã‚¹ãƒˆè¦ç´ 
   - ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰UIãƒ†ã‚¹ãƒˆ
   - å¤šè¨€èªè¡¨ç¤ºãƒ†ã‚¹ãƒˆ
   - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
   - ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
   ```

10. **UI/UXãƒãƒªãƒƒã‚·ãƒ¥**
    - **ä¾å­˜**: çµ±åˆãƒ†ã‚¹ãƒˆå®Œäº†
    - **æœŸé–“**: 2æ—¥
    - **å†…å®¹**: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ç´°éƒ¨èª¿æ•´
    ```swift
    // æœ€çµ‚èª¿æ•´è¦ç´ 
    - ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    - è¨€èªåˆ‡ã‚Šæ›¿ãˆã‚¹ãƒ ãƒ¼ã‚ºåŒ–
    - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ”¹å–„
    - ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š
    ```

### ãƒªã‚¹ã‚¯ç®¡ç†ã¨ä»£æ›¿æ¡ˆ

#### é«˜ãƒªã‚¹ã‚¯ä¾å­˜é–¢ä¿‚

1. **å¤–éƒ¨APIä¾å­˜ (å¤©æ°—ãƒ»èŠ±ç²‰ãƒ»AQI)**
   - **ãƒªã‚¹ã‚¯**: APIéšœå®³ãƒ»ãƒ¬ãƒ¼ãƒˆåˆ¶é™
   - **ä»£æ›¿æ¡ˆ**: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥
   - **å¯¾ç­–æœŸé–“**: 1æ—¥è¿½åŠ ã§ãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…

2. **Claude AI APIçµ±åˆ**
   - **ãƒªã‚¹ã‚¯**: ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¸å®‰å®šãƒ»ã‚³ã‚¹ãƒˆ
   - **ä»£æ›¿æ¡ˆ**: ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æŒ¨æ‹¶ç”Ÿæˆ
   - **å¯¾ç­–æœŸé–“**: åŠæ—¥ã§é™çš„ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…

3. **HealthKitæ¨©é™ãƒ»ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹**
   - **ãƒªã‚¹ã‚¯**: iOSæ¨©é™æ‹’å¦ãƒ»ãƒ‡ãƒ¼ã‚¿ä¸è¶³
   - **ä»£æ›¿æ¡ˆ**: ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ»æ‰‹å‹•å…¥åŠ›
   - **å¯¾ç­–æœŸé–“**: 1æ—¥ã§ãƒ¢ãƒƒã‚¯çµ±åˆ

#### ä¸¦åˆ—é–‹ç™ºæˆ¦ç•¥

```mermaid
gantt
    title Phase 1 ä¸¦åˆ—é–‹ç™ºã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    dateFormat  X
    axisFormat %d
    
    section iOSé–‹ç™º
    ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³åŸºç›¤    :1, 2
    UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç¾¤         :2, 5
    ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼      :5, 9
    HomeViewçµ±åˆ             :9, 12
    UI/UXãƒãƒªãƒƒã‚·ãƒ¥           :12, 14
    
    section ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™º
    ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©          :1, 3
    ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹API       :3, 6
    ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆAPI          :6, 10
    å¤©æ°—çµ±åˆAPI             :10, 13
    
    section QAãƒ»çµ±åˆ
    ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ            :5, 13
    çµ±åˆãƒ†ã‚¹ãƒˆ               :13, 16
    E2Eãƒ†ã‚¹ãƒˆ               :16, 18
```

**æœ€é©åŒ–ã•ã‚ŒãŸé–‹ç™ºæœŸé–“**: 18æ—¥ (3.6é€±)
**å¾“æ¥ã®é€æ¬¡é–‹ç™ºæœŸé–“**: 28æ—¥ (5.6é€±)
**åŠ¹ç‡åŒ–**: 36%çŸ­ç¸®

### ä¾å­˜é–¢ä¿‚ãƒªã‚¹ã‚¯ç®¡ç†ãƒãƒˆãƒªã‚¯ã‚¹

#### é«˜ãƒªã‚¹ã‚¯ä¾å­˜é–¢ä¿‚ã®è©³ç´°åˆ†æ

| ä¾å­˜é–¢ä¿‚ | ãƒªã‚¹ã‚¯åº¦ | å½±éŸ¿ç¯„å›² | ç·©å’Œç­– | ä»£æ›¿æ¡ˆ | æ¤œè¨¼æ–¹æ³• |
|----------|---------|---------|--------|--------|----------|
| **HealthKitæ¨©é™å–å¾—** | ğŸ”´ High | å…¨æ©Ÿèƒ½ | æ®µéšçš„è¦æ±‚ãƒ»ãƒ‡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ | æ‰‹å‹•å…¥åŠ›ãƒ»ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ | æ¨©é™æ‹’å¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ |
| **Claude APIå¯ç”¨æ€§** | ğŸŸ  Medium | æŒ¨æ‹¶ç”Ÿæˆ | ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ | ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ç”Ÿæˆ | APIéšœå®³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ |
| **å¤–éƒ¨å¤©æ°—API** | ğŸŸ¡ Low | ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆ | è¤‡æ•°ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥ | åœ°åŸŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ | APIåˆ¶é™ãƒ†ã‚¹ãƒˆ |
| **å¤šè¨€èªãƒªã‚½ãƒ¼ã‚¹** | ğŸŸ  Medium | UIå…¨ä½“ | æ®µéšçš„ç¿»è¨³ãƒ»è‡ªå‹•æ¤œè¨¼ | è‹±èªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ | ç¿»è¨³å“è³ªæ¤œè¨¼ |
| **SwiftUIäº’æ›æ€§** | ğŸŸ¡ Low | iOS UI | iOSæœ€å°ãƒãƒ¼ã‚¸ãƒ§ãƒ³å›ºå®š | UIKitéƒ¨åˆ†å®Ÿè£… | ãƒ‡ãƒã‚¤ã‚¹ãƒ†ã‚¹ãƒˆ |

#### ä¾å­˜é–¢ä¿‚åˆ¥å®Ÿè£…æˆ¦ç•¥

**1. HealthKitä¾å­˜é–¢ä¿‚ç®¡ç†**

```swift
// ios/TempoAI/TempoAI/Services/HealthKitDependencyManager.swift
class HealthKitDependencyManager {
    private enum DependencyState {
        case notRequested
        case requesting
        case authorized
        case denied
        case unavailable
    }
    
    @Published private(set) var state: DependencyState = .notRequested
    @Published private(set) var fallbackMode: Bool = false
    
    // æ®µéšçš„ä¾å­˜é–¢ä¿‚è§£æ±º
    func resolveHealthKitDependency() async -> HealthKitResolution {
        state = .requesting
        
        // Step 1: å¯ç”¨æ€§ç¢ºèª
        guard HKHealthStore.isHealthDataAvailable() else {
            state = .unavailable
            return activateFallbackMode(.deviceUnsupported)
        }
        
        // Step 2: æ¨©é™è¦æ±‚
        do {
            try await requestHealthKitPermissions()
            state = .authorized
            return .authorized
        } catch {
            state = .denied
            return activateFallbackMode(.permissionDenied)
        }
    }
    
    private func activateFallbackMode(_ reason: FallbackReason) -> HealthKitResolution {
        fallbackMode = true
        return .fallback(reason: reason, demoData: generateDemoHealthData())
    }
    
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ä¾å­˜é–¢ä¿‚ç›£è¦–
    func monitorHealthKitAvailability() {
        // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã®ä¾å­˜é–¢ä¿‚å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
        Timer.publish(every: 300, on: .main, in: .common) // 5åˆ†é–“éš”
            .autoconnect()
            .sink { _ in
                Task { await self.validateDependencyHealth() }
            }
            .store(in: &cancellables)
    }
}

enum HealthKitResolution {
    case authorized
    case fallback(reason: FallbackReason, demoData: HealthData)
}

enum FallbackReason {
    case deviceUnsupported
    case permissionDenied
    case dataUnavailable
}
```

**2. APIä¾å­˜é–¢ä¿‚ç®¡ç†**

```swift
// ios/TempoAI/TempoAI/Services/APIDependencyManager.swift
class APIDependencyManager: ObservableObject {
    private let healthCheckInterval: TimeInterval = 60 // 1åˆ†é–“éš”
    
    @Published private(set) var apiHealthStatus: [APIService: ServiceHealth] = [:]
    
    func initializeAPIDependencies() async {
        // ä¸¦åˆ—ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
        await withTaskGroup(of: (APIService, ServiceHealth).self) { group in
            for service in APIService.allCases {
                group.addTask {
                    let health = await self.checkServiceHealth(service)
                    return (service, health)
                }
            }
            
            for await (service, health) in group {
                await MainActor.run {
                    self.apiHealthStatus[service] = health
                }
            }
        }
        
        // ç¶™ç¶šçš„ãªå¥å…¨æ€§ç›£è¦–
        startContinuousHealthMonitoring()
    }
    
    private func checkServiceHealth(_ service: APIService) async -> ServiceHealth {
        do {
            let response = try await performHealthCheck(service)
            return ServiceHealth(
                status: .healthy,
                responseTime: response.responseTime,
                lastChecked: Date(),
                errorCount: 0
            )
        } catch {
            return ServiceHealth(
                status: .unhealthy,
                responseTime: nil,
                lastChecked: Date(),
                errorCount: 1,
                lastError: error
            )
        }
    }
    
    // è‡ªå‹•ãƒ•ã‚§ã‚¤ãƒ«ã‚ªãƒ¼ãƒãƒ¼
    func getServiceWithFailover(_ primaryService: APIService) -> APIService {
        guard let primaryHealth = apiHealthStatus[primaryService],
              primaryHealth.status == .healthy else {
            return primaryService.fallbackService
        }
        return primaryService
    }
}

enum APIService: CaseIterable {
    case claude
    case weather
    case environmental
    
    var fallbackService: APIService {
        switch self {
        case .claude: return .claude // ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ç”Ÿæˆã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        case .weather: return .weather // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿ä½¿ç”¨
        case .environmental: return .environmental // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä½¿ç”¨
        }
    }
}

struct ServiceHealth {
    let status: HealthStatus
    let responseTime: TimeInterval?
    let lastChecked: Date
    let errorCount: Int
    let lastError: Error?
    
    enum HealthStatus {
        case healthy
        case degraded
        case unhealthy
    }
}
```

**3. å¤šè¨€èªãƒªã‚½ãƒ¼ã‚¹ä¾å­˜é–¢ä¿‚ç®¡ç†**

```swift
// ios/TempoAI/TempoAI/Services/LocalizationDependencyManager.swift
class LocalizationDependencyManager: ObservableObject {
    @Published private(set) var localizationHealth: LocalizationHealth
    
    init() {
        self.localizationHealth = validateLocalizationCompleteness()
    }
    
    func validateLocalizationCompleteness() -> LocalizationHealth {
        let requiredKeys = LocalizationKeys.allCases
        var missingJapanese: [String] = []
        var missingEnglish: [String] = []
        var suspiciousTranslations: [String] = []
        
        for key in requiredKeys {
            let japanese = NSLocalizedString(key.rawValue, bundle: .japanese, value: "MISSING", comment: "")
            let english = NSLocalizedString(key.rawValue, bundle: .english, value: "MISSING", comment: "")
            
            if japanese == "MISSING" || japanese == key.rawValue {
                missingJapanese.append(key.rawValue)
            }
            
            if english == "MISSING" || english == key.rawValue {
                missingEnglish.append(key.rawValue)
            }
            
            // è‡ªå‹•ç¿»è¨³å“è³ªãƒã‚§ãƒƒã‚¯
            if detectMachineTranslation(japanese) {
                suspiciousTranslations.append(key.rawValue)
            }
        }
        
        let completeness = Double(requiredKeys.count - missingJapanese.count - missingEnglish.count) / Double(requiredKeys.count * 2)
        
        return LocalizationHealth(
            completeness: completeness,
            missingJapanese: missingJapanese,
            missingEnglish: missingEnglish,
            suspiciousTranslations: suspiciousTranslations,
            isProductionReady: completeness >= 0.95 && suspiciousTranslations.count <= 5
        )
    }
    
    private func detectMachineTranslation(_ text: String) -> Bool {
        let unnaturalPatterns = [
            "ã‚ãªãŸã®", // éåº¦ãªä½¿ç”¨
            "ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™", // å†—é•·è¡¨ç¾
            "ã§ã—ã¦ãã ã•ã„", // ä¸è‡ªç„¶ãªæ•¬èª
        ]
        
        return unnaturalPatterns.contains { text.contains($0) }
    }
}

struct LocalizationHealth {
    let completeness: Double // 0.0 - 1.0
    let missingJapanese: [String]
    let missingEnglish: [String]
    let suspiciousTranslations: [String]
    let isProductionReady: Bool
}
```

### ä¾å­˜é–¢ä¿‚å„ªå…ˆåº¦ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

#### å‹•çš„å„ªå…ˆåº¦è¨ˆç®—

```swift
// ios/TempoAI/TempoAI/Utils/DependencyPriorityCalculator.swift
struct DependencyPriorityCalculator {
    
    static func calculatePriority(_ dependency: Dependency) -> Priority {
        let impact = calculateBusinessImpact(dependency)
        let risk = calculateImplementationRisk(dependency)
        let effort = calculateImplementationEffort(dependency)
        let blockers = calculateBlockingFactor(dependency)
        
        let score = (impact * 0.4 + risk * 0.3 + blockers * 0.2 + (1.0 - effort) * 0.1)
        
        switch score {
        case 0.8...1.0: return .critical
        case 0.6..<0.8: return .high
        case 0.4..<0.6: return .medium
        default: return .low
        }
    }
    
    private static func calculateBusinessImpact(_ dependency: Dependency) -> Double {
        switch dependency {
        case .healthKitIntegration: return 1.0 // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã«ç›´æ¥å½±éŸ¿
        case .localizationResources: return 0.9 // æ—¥æœ¬å¸‚å ´å¿…é ˆ
        case .claudeAPIIntegration: return 0.7 // å·®åˆ¥åŒ–æ©Ÿèƒ½
        case .weatherAPIIntegration: return 0.5 // ä»˜åŠ ä¾¡å€¤æ©Ÿèƒ½
        case .uiComponentLibrary: return 0.6 // é–‹ç™ºåŠ¹ç‡å½±éŸ¿
        }
    }
    
    private static func calculateImplementationRisk(_ dependency: Dependency) -> Double {
        switch dependency {
        case .healthKitIntegration: return 0.8 // æ¨©é™ãƒ»ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼èª²é¡Œ
        case .claudeAPIIntegration: return 0.7 // å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ä¾å­˜
        case .localizationResources: return 0.3 // å®Ÿè£…æ˜ç¢º
        case .weatherAPIIntegration: return 0.4 // æ¨™æº–çš„API
        case .uiComponentLibrary: return 0.2 // æŠ€è¡“çš„ã«å˜ç´”
        }
    }
    
    private static func calculateBlockingFactor(_ dependency: Dependency) -> Double {
        // ä»–ã®ä¾å­˜é–¢ä¿‚ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹åº¦åˆã„
        switch dependency {
        case .localizationResources: return 1.0 // å…¨UIè¦ç´ ã‚’ãƒ–ãƒ­ãƒƒã‚¯
        case .uiComponentLibrary: return 0.9 // å¤šãã®Viewã‚’ãƒ–ãƒ­ãƒƒã‚¯
        case .healthKitIntegration: return 0.6 // ãƒ˜ãƒ«ã‚¹æ©Ÿèƒ½ã‚’ãƒ–ãƒ­ãƒƒã‚¯
        case .claudeAPIIntegration: return 0.4 // AIæ©Ÿèƒ½ã®ã¿ãƒ–ãƒ­ãƒƒã‚¯
        case .weatherAPIIntegration: return 0.3 // ç’°å¢ƒæ©Ÿèƒ½ã®ã¿ãƒ–ãƒ­ãƒƒã‚¯
        }
    }
}

enum Dependency {
    case healthKitIntegration
    case localizationResources
    case claudeAPIIntegration
    case weatherAPIIntegration
    case uiComponentLibrary
}

enum Priority: Int, Comparable {
    case critical = 4
    case high = 3
    case medium = 2
    case low = 1
    
    static func < (lhs: Priority, rhs: Priority) -> Bool {
        lhs.rawValue < rhs.rawValue
    }
}
```

### ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ä¾å­˜é–¢ä¿‚ç›£è¦–

#### ä¾å­˜é–¢ä¿‚ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

```swift
// ios/TempoAI/TempoAI/Views/Debug/DependencyDashboardView.swift
struct DependencyDashboardView: View {
    @StateObject private var dependencyMonitor = DependencyMonitor()
    
    var body: some View {
        NavigationStack {
            List {
                Section("Critical Dependencies") {
                    ForEach(dependencyMonitor.criticalDependencies, id: \.name) { dep in
                        DependencyStatusRow(dependency: dep)
                    }
                }
                
                Section("Health Metrics") {
                    HStack {
                        Text("Overall Health")
                        Spacer()
                        CircularProgressView(progress: dependencyMonitor.overallHealth)
                    }
                    
                    HStack {
                        Text("Production Readiness")
                        Spacer()
                        Text(dependencyMonitor.isProductionReady ? "âœ… Ready" : "âš ï¸ Not Ready")
                    }
                }
                
                Section("Mitigation Status") {
                    ForEach(dependencyMonitor.activeMitigations, id: \.id) { mitigation in
                        MitigationStatusRow(mitigation: mitigation)
                    }
                }
            }
            .navigationTitle("Dependencies")
            .refreshable {
                await dependencyMonitor.refreshAllDependencies()
            }
        }
    }
}

class DependencyMonitor: ObservableObject {
    @Published var criticalDependencies: [DependencyStatus] = []
    @Published var overallHealth: Double = 0.0
    @Published var isProductionReady: Bool = false
    @Published var activeMitigations: [MitigationStatus] = []
    
    func refreshAllDependencies() async {
        // ä¸¦åˆ—ã§å…¨ä¾å­˜é–¢ä¿‚ã‚’ãƒã‚§ãƒƒã‚¯
        async let healthKit = checkHealthKitDependency()
        async let apis = checkAPIDependencies()
        async let localization = checkLocalizationDependency()
        async let ui = checkUIComponentDependencies()
        
        let results = await [healthKit, apis, localization, ui].flatMap { $0 }
        
        await MainActor.run {
            self.criticalDependencies = results.filter { $0.priority >= .high }
            self.overallHealth = calculateOverallHealth(results)
            self.isProductionReady = results.allSatisfy { $0.isHealthy }
            self.activeMitigations = getActiveMitigations(results)
        }
    }
}
```

---

## âš ï¸ æƒ³å®šã•ã‚Œã‚‹èª²é¡Œã¨è§£æ±ºç­–

### 1. HealthKitæ¨©é™ãƒ»ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹èª²é¡Œ

#### èª²é¡Œè©³ç´°
- **æ¨©é™æ‹’å¦ç‡**: iOS14ä»¥é™ç´„30%ãŒåˆå›æ‹’å¦
- **ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆ**: è¤‡æ•°ã‚½ãƒ¼ã‚¹é–“ã§ã®ãƒ‡ãƒ¼ã‚¿å“è³ªå·®
- **ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼æ‡¸å¿µ**: æ—¥æœ¬å¸‚å ´ã§ã®å¥åº·ãƒ‡ãƒ¼ã‚¿æ„Ÿåº¦é«˜

#### è§£æ±ºç­–

**A. æ®µéšçš„æ¨©é™è¦æ±‚æˆ¦ç•¥**
```swift
// ios/TempoAI/TempoAI/Services/HealthKitPermissionManager.swift
class HealthKitPermissionManager {
    
    // æ®µéšçš„æ¨©é™è¦æ±‚ï¼ˆåœ§è¿«æ„Ÿã‚’è»½æ¸›ï¼‰
    func requestPermissionsGradually() async {
        // Step 1: åŸºæœ¬çš„ãªæ­©æ•°ã®ã¿
        let basicTypes: Set<HKObjectType> = [HKObjectType.quantityType(forIdentifier: .stepCount)!]
        await requestPermission(for: basicTypes, reason: .basicActivity)
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ…£ã‚ŒãŸã‚‰è¿½åŠ æ¨©é™
        if isUserEngaged() {
            // Step 2: å¿ƒæ‹æ•°ãƒ»ç¡çœ è¿½åŠ 
            let advancedTypes: Set<HKObjectType> = [
                HKObjectType.quantityType(forIdentifier: .heartRate)!,
                HKCategoryType.categoryType(forIdentifier: .sleepAnalysis)!
            ]
            await requestPermission(for: advancedTypes, reason: .detailedAnalysis)
        }
    }
    
    // æ¨©é™æ‹’å¦æ™‚ã®ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«å¯¾å¿œ
    func handlePermissionDenied() {
        // ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã§ãƒ‡ãƒ¢ä½“é¨“æä¾›
        HealthDataManager.shared.enableDemoMode()
        
        // å¾Œã§ã®æ¨©é™è¨±å¯ã‚’ä¿ƒã™UIè¡¨ç¤º
        showPermissionEducationView()
    }
}
```

**B. ãƒ‡ãƒ¼ã‚¿å“è³ªä¿è¨¼ã‚·ã‚¹ãƒ†ãƒ **
```swift
// ios/TempoAI/TempoAI/Services/HealthDataValidator.swift
class HealthDataValidator {
    
    func validateAndNormalize(_ rawData: HKSample) -> ValidatedHealthData? {
        // ç•°å¸¸å€¤æ¤œå‡º
        guard isWithinReasonableRange(rawData) else {
            logDataAnomalY(rawData)
            return nil
        }
        
        // ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ä¿¡é ¼åº¦è©•ä¾¡
        let trustScore = calculateTrustScore(rawData.sourceRevision)
        guard trustScore >= minimumTrustThreshold else {
            return nil
        }
        
        // æ­£è¦åŒ–å‡¦ç†
        return ValidatedHealthData(
            value: normalizeValue(rawData),
            confidence: trustScore,
            timestamp: rawData.startDate
        )
    }
    
    private func isWithinReasonableRange(_ sample: HKSample) -> Bool {
        // å¿ƒæ‹æ•°: 40-200 bpm
        // æ­©æ•°: 0-50000 steps/day
        // ç¡çœ : 2-16 hours
        // å¹´é½¢ãƒ»æ€§åˆ¥ã«ã‚ˆã‚‹è£œæ­£
    }
}
```

**C. ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼é‡è¦–è¨­è¨ˆ**
```swift
// ios/TempoAI/TempoAI/Services/PrivacyManager.swift
class PrivacyManager {
    
    // ãƒ‡ãƒã‚¤ã‚¹å†…ã§ã®åŒ¿ååŒ–å‡¦ç†
    func anonymizeHealthData(_ data: HealthData) -> AnonymizedHealthData {
        return AnonymizedHealthData(
            heartRateCategory: categorizeHeartRate(data.heartRate),
            sleepQualityLevel: categorizeSleep(data.sleepDuration),
            activityLevel: categorizeActivity(data.stepCount),
            // å…·ä½“çš„ãªæ•°å€¤ã¯é€ä¿¡ã—ãªã„
            timestamp: data.timestamp.truncatedToHour
        )
    }
    
    // æ—¥æœ¬ã®ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼æ³•è¦åˆ¶éµå®ˆ
    func ensureJapanesePrivacyCompliance() {
        // å€‹äººæƒ…å ±ä¿è­·æ³•æº–æ‹ 
        // åŒ»ç™‚æ©Ÿå™¨ç­‰è¦åˆ¶æ³•è€ƒæ…®
        // åˆ©ç”¨ç›®çš„æ˜ç¤ºãƒ»åŒæ„å–å¾—
    }
}
```

### 2. éåŒæœŸå‡¦ç†ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹èª²é¡Œ

#### èª²é¡Œè©³ç´°
- **è¤‡æ•°APIä¸¦åˆ—å‘¼ã³å‡ºã—**: Claude AI + Weather + HealthKit
- **UIå¿œç­”æ€§**: iOS Main Actoråˆ¶ç´„
- **ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸å®‰å®š**: æ—¥æœ¬ã®ç§»å‹•ç’°å¢ƒ

#### è§£æ±ºç­–

**A. æ§‹é€ åŒ–ä¸¦è¡Œæ€§ãƒ‘ã‚¿ãƒ¼ãƒ³**
```swift
// ios/TempoAI/TempoAI/Services/DataAggregationService.swift
class DataAggregationService {
    
    func aggregateDailyData() async throws -> DailyDataSummary {
        // TaskGroupä½¿ç”¨ã§æ§‹é€ åŒ–ä¸¦è¡Œæ€§
        try await withThrowingTaskGroup(of: DataComponent.self) { group in
            
            // ä¸¦åˆ—ãƒ‡ãƒ¼ã‚¿å–å¾—
            group.addTask {
                let health = try await HealthKitService.shared.getTodayHealthData()
                return .health(health)
            }
            
            group.addTask {
                let weather = try await WeatherService.shared.getCurrentWeather()
                return .weather(weather)
            }
            
            group.addTask {
                let environmental = try await EnvironmentalService.shared.getAlerts()
                return .environmental(environmental)
            }
            
            // çµæœåé›†
            var healthData: HealthData?
            var weatherData: WeatherData?
            var environmentalData: [EnvironmentalAlert] = []
            
            for try await component in group {
                switch component {
                case .health(let data): healthData = data
                case .weather(let data): weatherData = data
                case .environmental(let data): environmentalData = data
                }
            }
            
            // å¿…é ˆãƒ‡ãƒ¼ã‚¿ç¢ºèª
            guard let health = healthData, let weather = weatherData else {
                throw DataAggregationError.incompleteData
            }
            
            return DailyDataSummary(
                health: health,
                weather: weather,
                environmental: environmentalData
            )
        }
    }
}
```

**B. ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥**
```swift
// ios/TempoAI/TempoAI/Services/CacheManager.swift
class CacheManager {
    
    private let memoryCache = NSCache<NSString, CachedData>()
    private let persistentCache = UserDefaults.standard
    
    func getCachedOrFetch<T: Codable>(
        key: String,
        maxAge: TimeInterval,
        fetcher: () async throws -> T
    ) async throws -> T {
        
        // ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèª
        if let cached = memoryCache.object(forKey: key as NSString),
           cached.isValid(maxAge: maxAge) {
            return cached.data as! T
        }
        
        // æ°¸ç¶šã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèª
        if let cachedData = getPersistentCache(key: key, type: T.self, maxAge: maxAge) {
            // ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«æ˜‡æ ¼
            memoryCache.setObject(CachedData(data: cachedData), forKey: key as NSString)
            return cachedData
        }
        
        // æ–°è¦å–å¾—
        let freshData = try await fetcher()
        
        // ä¸¡æ–¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
        memoryCache.setObject(CachedData(data: freshData), forKey: key as NSString)
        setPersistentCache(key: key, data: freshData)
        
        return freshData
    }
}
```

**C. æ®µéšçš„ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æˆ¦ç•¥**
```swift
// ios/TempoAI/TempoAI/ViewModels/HomeViewModel.swift
class HomeViewModel: ObservableObject {
    @Published var loadingStage: LoadingStage = .initial
    @Published var quickData: QuickSummary?
    @Published var detailedData: DetailedAnalysis?
    
    func loadDataInStages() async {
        await MainActor.run {
            loadingStage = .loadingQuickSummary
        }
        
        // Stage 1: å³åº§ã«è¡¨ç¤ºå¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»ãƒ­ãƒ¼ã‚«ãƒ«ï¼‰
        let quick = await loadQuickSummary() // 0.1ç§’ä»¥å†…
        await MainActor.run {
            self.quickData = quick
            self.loadingStage = .loadingDetailedAnalysis
        }
        
        // Stage 2: è©³ç´°åˆ†æï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
        do {
            let detailed = try await loadDetailedAnalysis() // 1-3ç§’
            await MainActor.run {
                self.detailedData = detailed
                self.loadingStage = .complete
            }
        } catch {
            await MainActor.run {
                self.loadingStage = .error(error)
            }
        }
    }
    
    private func loadQuickSummary() async -> QuickSummary {
        // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ã¿ä½¿ç”¨ã€å³åº§ã«è¡¨ç¤º
        return QuickSummary(
            lastKnownStatus: getCachedHealthStatus(),
            basicGreeting: generateBasicGreeting(),
            timestamp: Date()
        )
    }
}
```

### 3. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»å¾©æ—§èª²é¡Œ

#### èª²é¡Œè©³ç´°
- **ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ–­ç¶š**: é›»è»Šç§»å‹•ä¸­ã®APIå¤±æ•—
- **APIåˆ¶é™**: Claude AI ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ»ã‚³ã‚¹ãƒˆ
- **ãƒ‡ãƒã‚¤ã‚¹åˆ¶ç´„**: ãƒ¡ãƒ¢ãƒªä¸è¶³ãƒ»ãƒãƒƒãƒ†ãƒªãƒ¼æ¶ˆè€—

#### è§£æ±ºç­–

**A. å¾©æ—§åŠ›ã®é«˜ã„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**
```swift
// ios/TempoAI/TempoAI/Utils/ErrorRecoveryManager.swift
class ErrorRecoveryManager {
    
    func handleWithRecovery<T>(
        operation: () async throws -> T,
        recoveryStrategies: [RecoveryStrategy<T>]
    ) async -> Result<T, AppError> {
        
        do {
            let result = try await operation()
            return .success(result)
        } catch {
            // å›å¾©æˆ¦ç•¥ã‚’é †æ¬¡å®Ÿè¡Œ
            for strategy in recoveryStrategies {
                if let recovered = try? await strategy.attempt(error) {
                    return .success(recovered)
                }
            }
            
            return .failure(AppError.unrecoverable(error))
        }
    }
}

// å…·ä½“çš„ãªå›å¾©æˆ¦ç•¥
struct CacheRecoveryStrategy<T>: RecoveryStrategy {
    func attempt(_ error: Error) async throws -> T {
        if error is NetworkError {
            return try await CacheManager.shared.getLastKnownData()
        }
        throw error
    }
}

struct FallbackDataStrategy<T>: RecoveryStrategy {
    func attempt(_ error: Error) async throws -> T {
        if error is APIError {
            return generateFallbackData()
        }
        throw error
    }
}
```

**B. ãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–ã‚¨ãƒ©ãƒ¼è¡¨ç¤º**
```swift
// ios/TempoAI/TempoAI/Views/Components/ErrorStateView.swift
struct ErrorStateView: View {
    let error: AppError
    let retryAction: () async -> Void
    
    var body: some View {
        VStack(spacing: 16) {
            errorIconView
            errorMessageView
            actionButtonsView
        }
        .padding()
    }
    
    private var errorMessageView: some View {
        VStack(spacing: 8) {
            Text(error.userFriendlyTitle)
                .font(.headline)
                .multilineTextAlignment(.center)
            
            Text(error.userFriendlyDescription)
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
        }
    }
    
    private var actionButtonsView: some View {
        VStack(spacing: 12) {
            // ãƒ—ãƒ©ã‚¤ãƒãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆãƒªãƒˆãƒ©ã‚¤ç­‰ï¼‰
            Button(action: { Task { await retryAction() } }) {
                HStack {
                    Image(systemName: "arrow.clockwise")
                    Text("retry".localized)
                }
                .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            
            // ã‚»ã‚«ãƒ³ãƒ€ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç¶šè¡Œç­‰ï¼‰
            if error.allowsOfflineMode {
                Button("continue_offline".localized) {
                    // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ç¶šè¡Œ
                }
                .buttonStyle(.bordered)
            }
        }
    }
}
```

**C. é©å¿œçš„å“è³ªèª¿æ•´**
```swift
// ios/TempoAI/TempoAI/Services/QualityAdaptationService.swift
class QualityAdaptationService {
    
    func adaptToDeviceConditions() async -> QualitySettings {
        let batteryLevel = await getBatteryLevel()
        let networkQuality = await assessNetworkQuality()
        let memoryPressure = await getMemoryPressure()
        
        return QualitySettings(
            // ãƒãƒƒãƒ†ãƒªãƒ¼ä½ä¸‹æ™‚ã¯æ©Ÿèƒ½åˆ¶é™
            enableBackgroundRefresh: batteryLevel > 0.2,
            
            // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å“è³ªã«å¿œã˜ãŸç”»åƒãƒ»ãƒ‡ãƒ¼ã‚¿å“è³ª
            dataQuality: networkQuality > 0.8 ? .high : .basic,
            
            // ãƒ¡ãƒ¢ãƒªåœ§è¿«æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºç¸®å°
            cacheSize: memoryPressure < 0.7 ? .large : .minimal,
            
            // APIå‘¼ã³å‡ºã—é »åº¦èª¿æ•´
            refreshInterval: networkQuality > 0.6 ? .normal : .reduced
        )
    }
    
    private func assessNetworkQuality() async -> Double {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é€Ÿåº¦ãƒ»å®‰å®šæ€§ãƒ†ã‚¹ãƒˆ
        // ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ»ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆæ¸¬å®š
        // 0.0 (æœ€æ‚ª) - 1.0 (æœ€è‰¯) ã§è©•ä¾¡
    }
}
```

### 4. å¤šè¨€èªå¯¾å¿œãƒ»æ–‡åŒ–é©å¿œèª²é¡Œ

#### èª²é¡Œè©³ç´°
- **æ—¥æœ¬èªè¡¨ç¾ã®è‡ªç„¶æ€§**: æ©Ÿæ¢°çš„ç¿»è¨³ã®å›é¿
- **ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå´©ã‚Œ**: æ—¥è‹±æ–‡å­—é•·å·®ã«ã‚ˆã‚‹UIå´©ã‚Œ
- **æ–‡åŒ–çš„é…æ…®**: å¥åº·ãƒ»é‹å‹•ã«é–¢ã™ã‚‹æ—¥æœ¬ç‰¹æœ‰ã®è€ƒãˆæ–¹

#### è§£æ±ºç­–

**A. å‹•çš„ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´**
```swift
// ios/TempoAI/TempoAI/Utils/LocalizedLayoutManager.swift
class LocalizedLayoutManager {
    
    static func calculateOptimalLayout(
        for text: String,
        language: Language,
        containerWidth: CGFloat
    ) -> LayoutConfiguration {
        
        let font = language == .japanese ? Font.japaneseBody : Font.englishBody
        let textSize = text.boundingRect(
            with: CGSize(width: containerWidth - 32, height: .greatestFiniteMagnitude),
            options: .usesLineFragmentOrigin,
            attributes: [.font: UIFont.systemFont(ofSize: 16)],
            context: nil
        )
        
        return LayoutConfiguration(
            minimumHeight: textSize.height + (language == .japanese ? 20 : 10),
            lineSpacing: language == .japanese ? 6 : 2,
            padding: EdgeInsets(
                top: 12,
                leading: 16,
                bottom: 12,
                trailing: 16
            )
        )
    }
}

// è‡ªå‹•èª¿æ•´ã•ã‚Œã‚‹ViewModifier
struct LocalizedLayoutModifier: ViewModifier {
    let text: String
    @StateObject private var localization = LocalizationManager.shared
    
    func body(content: Content) -> some View {
        let config = LocalizedLayoutManager.calculateOptimalLayout(
            for: text,
            language: localization.currentLanguage,
            containerWidth: UIScreen.main.bounds.width
        )
        
        content
            .frame(minHeight: config.minimumHeight)
            .padding(config.padding)
            .lineSpacing(config.lineSpacing)
    }
}
```

**B. æ–‡åŒ–é©å¿œè¡¨ç¾ã‚¨ãƒ³ã‚¸ãƒ³**
```swift
// ios/TempoAI/TempoAI/Services/CulturalAdaptationService.swift
class CulturalAdaptationService {
    
    func adaptHealthAdvice(
        _ advice: DailyAdvice,
        for culture: Culture
    ) -> DailyAdvice {
        
        switch culture {
        case .japanese:
            return adaptForJapanese(advice)
        case .western:
            return advice // ãã®ã¾ã¾ä½¿ç”¨
        }
    }
    
    private func adaptForJapanese(_ advice: DailyAdvice) -> DailyAdvice {
        return DailyAdvice(
            meal: adaptMealAdviceForJapanese(advice.meal),
            exercise: adaptExerciseAdviceForJapanese(advice.exercise),
            wellness: adaptWellnessAdviceForJapanese(advice.wellness),
            summary: adaptSummaryForJapanese(advice.summary)
        )
    }
    
    private func adaptMealAdviceForJapanese(_ meal: String) -> String {
        // æ—¥æœ¬ã®é£Ÿæ–‡åŒ–ã«é…æ…®
        // - å’Œé£Ÿä¸­å¿ƒã®ææ¡ˆ
        // - å­£ç¯€æ„Ÿã®ã‚ã‚‹é£Ÿæ
        // - é©åˆ‡ãªæ•¬èªãƒ»ä¸å¯§èª
        
        var adapted = meal
        
        // é£Ÿæåã®æ—¥æœ¬èªåŒ–
        adapted = adapted.replacingOccurrences(of: "quinoa", with: "ç„ç±³ã‚„é›‘ç©€")
        adapted = adapted.replacingOccurrences(of: "kale", with: "å°æ¾èœã‚„æ˜¥èŠ")
        
        // èª¿ç†æ³•ã®æ–‡åŒ–çš„é©å¿œ
        adapted = adapted.replacingOccurrences(of: "smoothie", with: "é‡èœã‚¸ãƒ¥ãƒ¼ã‚¹ã‚„ãŠå‘³å™Œæ±")
        
        // ã‚ˆã‚Šä¸å¯§ãªè¡¨ç¾ã«å¤‰æ›´
        adapted = adapted.replacingOccurrences(of: "é£Ÿã¹ã¦", with: "ãŠå¬ã—ä¸ŠãŒã‚Šãã ã•ã„")
        
        return adapted
    }
}
```

**C. ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–**
```swift
// ios/TempoAI/TempoAIUITests/LocalizationUsabilityTests.swift
class LocalizationUsabilityTests: XCTestCase {
    
    func testJapaneseLayoutStability() {
        let app = XCUIApplication()
        app.launch()
        
        // æ—¥æœ¬èªã«åˆ‡ã‚Šæ›¿ãˆ
        switchToJapanese()
        
        // å„ç”»é¢ã§ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå´©ã‚Œãƒã‚§ãƒƒã‚¯
        let criticalViews = [
            UIIdentifiers.Onboarding.welcomePage,
            UIIdentifiers.Home.todayView,
            UIIdentifiers.Advice.detailView
        ]
        
        for viewIdentifier in criticalViews {
            navigateToView(viewIdentifier)
            
            // ãƒ†ã‚­ã‚¹ãƒˆåˆ‡ã‚Šæ¨ã¦ãŒãªã„ã“ã¨ã‚’ç¢ºèª
            XCTAssertFalse(hasTextTruncation(), "\(viewIdentifier)ã§æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆãŒåˆ‡ã‚Œã¦ã„ã¾ã™")
            
            // ãƒœã‚¿ãƒ³ãŒç”»é¢å¤–ã«å‡ºã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
            XCTAssertTrue(allButtonsVisible(), "\(viewIdentifier)ã§ãƒœã‚¿ãƒ³ãŒç”»é¢å¤–ã«ã‚ã‚Šã¾ã™")
            
            // é©åˆ‡ãªè¡Œé–“ãƒ»ä½™ç™½ãŒã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
            XCTAssertTrue(hasProperSpacing(), "\(viewIdentifier)ã§æ—¥æœ¬èªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒä¸é©åˆ‡ã§ã™")
        }
    }
    
    func testCrossLanguageSwitching() {
        let app = XCUIApplication()
        app.launch()
        
        // ãƒ‡ãƒ¼ã‚¿å…¥åŠ›
        inputHealthData()
        
        // è¨€èªåˆ‡ã‚Šæ›¿ãˆå‰å¾Œã§ãƒ‡ãƒ¼ã‚¿ä¿æŒç¢ºèª
        let healthDataBefore = getDisplayedHealthData()
        
        switchToEnglish()
        let healthDataAfterEnglish = getDisplayedHealthData()
        
        switchToJapanese()
        let healthDataAfterJapanese = getDisplayedHealthData()
        
        // ãƒ‡ãƒ¼ã‚¿ä¸€è²«æ€§ç¢ºèª
        XCTAssertEqual(healthDataBefore.stepCount, healthDataAfterEnglish.stepCount)
        XCTAssertEqual(healthDataBefore.stepCount, healthDataAfterJapanese.stepCount)
    }
}
```

---

## ğŸŒ å®Œå…¨ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒªã‚½ãƒ¼ã‚¹å®šç¾©

### æ—¥è‹±200+é …ç›®å®Œå…¨ãƒãƒƒãƒ”ãƒ³ã‚°

#### ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–¢é€£ï¼ˆ40é …ç›®ï¼‰
```swift
// ios/TempoAI/TempoAI/Resources/ja.lproj/Localizable.strings
// MARK: - Onboarding
"onboarding_welcome_title" = "Tempo AI ã¸ã‚ˆã†ã“ã";
"onboarding_welcome_subtitle" = "ã‚ãªãŸã ã‘ã®ãƒ˜ãƒ«ã‚¹ã‚±ã‚¢ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼";
"onboarding_welcome_description" = "æ¯æœã€æœ€é©ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ã‚ãªãŸã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç”Ÿæˆã—ã¾ã™";
"onboarding_welcome_button_next" = "æ¬¡ã¸";
"onboarding_welcome_button_skip" = "ã‚¹ã‚­ãƒƒãƒ—";

"onboarding_data_title" = "3ã¤ã®ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆ";
"onboarding_data_body_title" = "ã‚ãªãŸã®ä½“ã®çŠ¶æ…‹";
"onboarding_data_body_description" = "ç¡çœ ã€å¿ƒæ‹ã€æ´»å‹•é‡ã‚’åˆ†æ";
"onboarding_data_environment_title" = "ä»Šæ—¥ã®ç’°å¢ƒ";
"onboarding_data_environment_description" = "æ°—åœ§ã€å¤©æ°—ã€èŠ±ç²‰æƒ…å ±ã‚’çµ±åˆ";
"onboarding_data_yesterday_title" = "æ˜¨æ—¥ã®éã”ã—æ–¹";
"onboarding_data_yesterday_description" = "å‰æ—¥ã®æ´»å‹•ã¨ä»Šæœã®çŠ¶æ…‹ã‚’æ¯”è¼ƒ";

"onboarding_analysis_title" = "AIãŒåˆ†æã™ã‚‹ã“ã¨";
"onboarding_analysis_description" = "ç·åˆçš„ã«åˆ†æã—ã¦æœ€é©ãª1æ—¥ã®ãƒ—ãƒ©ãƒ³ã‚’ç”Ÿæˆ";
"onboarding_analysis_reason" = "ãªãœã“ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãªã®ã‹ç†ç”±ã‚‚èª¬æ˜";

"onboarding_start_title" = "æ¯æœå±Šãã‚‚ã®";
"onboarding_start_meal" = "é£Ÿäº‹ãƒ—ãƒ©ãƒ³";
"onboarding_start_exercise" = "é‹å‹•ãƒ—ãƒ©ãƒ³";
"onboarding_start_wellness" = "éã”ã—æ–¹ãƒ—ãƒ©ãƒ³";
"onboarding_start_button" = "å§‹ã‚ã‚‹";
"onboarding_start_terms" = "åˆ©ç”¨è¦ç´„";
"onboarding_start_privacy" = "ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼";

// MARK: - Onboarding Permissions
"onboarding_permission_title" = "ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯";
"onboarding_permission_healthkit_title" = "ãƒ˜ãƒ«ã‚¹ã‚±ã‚¢ãƒ‡ãƒ¼ã‚¿";
"onboarding_permission_healthkit_description" = "ç¡çœ ã€å¿ƒæ‹ã€æ´»å‹•ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æã«ä½¿ç”¨";
"onboarding_permission_location_title" = "ä½ç½®æƒ…å ±";
"onboarding_permission_location_description" = "å¤©æ°—ã¨ç’°å¢ƒãƒ‡ãƒ¼ã‚¿å–å¾—ã«ä½¿ç”¨";
"onboarding_permission_notification_title" = "é€šçŸ¥";
"onboarding_permission_notification_description" = "æ¯æœã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹é€šçŸ¥";
"onboarding_permission_allow" = "è¨±å¯ã™ã‚‹";
"onboarding_permission_later" = "å¾Œã§è¨­å®š";
"onboarding_permission_required" = "â€»åŸºæœ¬æ©Ÿèƒ½ã«å¿…è¦ã§ã™";
```

#### ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹é–¢é€£ï¼ˆ30é …ç›®ï¼‰
```swift
// MARK: - Health Status
"health_status_title" = "ä»Šæ—¥ã®ã‚ãªãŸ";
"health_status_optimal" = "æœ€é©ãƒ¢ãƒ¼ãƒ‰";
"health_status_optimal_description" = "çµ¶å¥½èª¿ï¼ç©æ¥µçš„ã«æ´»å‹•ã—ã¾ã—ã‚‡ã†";
"health_status_optimal_emoji" = "ğŸŸ¢";
"health_status_standard" = "æ¨™æº–ãƒ¢ãƒ¼ãƒ‰";
"health_status_standard_description" = "é€šå¸¸é€šã‚Šã®æ´»å‹•ãŒå¯èƒ½ã§ã™";
"health_status_standard_emoji" = "ğŸŸ¡";
"health_status_care" = "ã‚±ã‚¢ãƒ¢ãƒ¼ãƒ‰";
"health_status_care_description" = "ä½“ã‚’åŠ´ã‚ã‚ŠãªãŒã‚‰éã”ã—ã¾ã—ã‚‡ã†";
"health_status_care_emoji" = "ğŸ”µ";
"health_status_rest" = "ä¼‘æ¯ãƒ¢ãƒ¼ãƒ‰";
"health_status_rest_description" = "ä»Šæ—¥ã¯ã‚†ã£ãã‚Šä¼‘é¤Šã‚’";
"health_status_rest_emoji" = "âš«";

"health_status_score_label" = "ã‚¹ã‚³ã‚¢";
"health_status_score_format" = "%d / 100";
"health_status_trend_improving" = "æ”¹å–„å‚¾å‘";
"health_status_trend_stable" = "å®‰å®š";
"health_status_trend_declining" = "è¦æ³¨æ„";

"health_status_detail_sleep" = "ç¡çœ ";
"health_status_detail_hrv" = "å¿ƒæ‹å¤‰å‹•";
"health_status_detail_activity" = "æ´»å‹•é‡";
"health_status_detail_recovery" = "å›å¾©åº¦";
```

#### å¤©æ°—æŒ¨æ‹¶ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆ50é …ç›®ï¼‰
```swift
// MARK: - Weather Greetings
"greeting_morning_sunny" = "å¿«æ™´ã®æœã§ã™ã­ã€%@ã•ã‚“";
"greeting_morning_cloudy" = "æ›‡ã‚Šç©ºã§ã™ãŒå…ƒæ°—ã«ã„ãã¾ã—ã‚‡ã†ã€%@ã•ã‚“";
"greeting_morning_rainy" = "é›¨ã®æœã§ã™ã­ã€%@ã•ã‚“";
"greeting_morning_snowy" = "é›ªã®æœã§ã™ã€æš–ã‹ãã—ã¦ãã ã•ã„ã€%@ã•ã‚“";
"greeting_morning_cold" = "å¯’ã„æœã§ã™ã­ã€%@ã•ã‚“";
"greeting_morning_hot" = "æš‘ã„æœã§ã™ã€æ°´åˆ†è£œçµ¦ã‚’å¿˜ã‚Œãšã«ã€%@ã•ã‚“";
"greeting_morning_comfortable" = "éã”ã—ã‚„ã™ã„æœã§ã™ã­ã€%@ã•ã‚“";

"greeting_afternoon_sunny" = "è‰¯ã„åˆå¾Œã‚’ãŠéã”ã—ãã ã•ã„ã€%@ã•ã‚“";
"greeting_afternoon_cloudy" = "åˆå¾Œã‚‚å…ƒæ°—ã«ã€%@ã•ã‚“";
"greeting_afternoon_rainy" = "é›¨ã®åˆå¾Œã§ã™ãŒä½“èª¿ç®¡ç†ã—ã£ã‹ã‚Šã¨ã€%@ã•ã‚“";

"greeting_evening_clear" = "è‰¯ã„å¤œã‚’ãŠéã”ã—ãã ã•ã„ã€%@ã•ã‚“";
"greeting_evening_cold" = "å¯’ã„å¤œã§ã™ã€æ¸©ã‹ãã—ã¦ãã ã•ã„ã€%@ã•ã‚“";

"greeting_generic_morning" = "ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã€%@ã•ã‚“";
"greeting_generic_afternoon" = "ã“ã‚“ã«ã¡ã¯ã€%@ã•ã‚“";
"greeting_generic_evening" = "ã“ã‚“ã°ã‚“ã¯ã€%@ã•ã‚“";
"greeting_generic_night" = "ãŠç–²ã‚Œæ§˜ã§ã—ãŸã€%@ã•ã‚“";

// æ°—æ¸©åˆ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
"greeting_temperature_very_cold" = "ã¨ã¦ã‚‚å¯’ã„ã§ã™ã€é˜²å¯’å¯¾ç­–ã‚’";
"greeting_temperature_cold" = "å°‘ã—è‚Œå¯’ã„ã§ã™ã­";
"greeting_temperature_comfortable" = "éã”ã—ã‚„ã™ã„æ°—æ¸©ã§ã™";
"greeting_temperature_warm" = "æš–ã‹ã„ä¸€æ—¥ã«ãªã‚Šãã†ã§ã™";
"greeting_temperature_hot" = "æš‘ã„ã§ã™ã€ç†±ä¸­ç—‡ã«æ³¨æ„";
"greeting_temperature_very_hot" = "çŒ›æš‘ã§ã™ã€ç„¡ç†ã¯ç¦ç‰©";
```

#### ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆé–¢é€£ï¼ˆ30é …ç›®ï¼‰
```swift
// MARK: - Environmental Alerts
"alert_pressure_title" = "æ°—åœ§å¤‰åŒ–ã‚¢ãƒ©ãƒ¼ãƒˆ";
"alert_pressure_dropping" = "æ°—åœ§ãŒæ€¥é™ä¸‹ã—ã¦ã„ã¾ã™";
"alert_pressure_low" = "ä½æ°—åœ§ãŒæ¥è¿‘ä¸­";
"alert_pressure_headache_warning" = "é ­ç—›ã«æ³¨æ„ã—ã¦ãã ã•ã„";
"alert_pressure_action_hydrate" = "æ°´åˆ†è£œçµ¦ã‚’å¿ƒãŒã‘ã‚‹";
"alert_pressure_action_medicine" = "é ­ç—›è–¬ã‚’æº–å‚™";
"alert_pressure_action_rest" = "ç„¡ç†ã‚’ã›ãšä¼‘æ†©ã‚’";

"alert_pollen_title" = "èŠ±ç²‰æƒ…å ±";
"alert_pollen_level_low" = "èŠ±ç²‰å°‘ãªã‚";
"alert_pollen_level_moderate" = "èŠ±ç²‰ã‚„ã‚„å¤šã‚";
"alert_pollen_level_high" = "èŠ±ç²‰å¤šã„";
"alert_pollen_level_very_high" = "èŠ±ç²‰éå¸¸ã«å¤šã„";
"alert_pollen_action_mask" = "ãƒã‚¹ã‚¯ç€ç”¨æ¨å¥¨";
"alert_pollen_action_wash" = "å¤–å‡ºå¾Œã®æ‰‹æ´—ã„ãƒ»æ´—é¡”";
"alert_pollen_action_medication" = "ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼è–¬ã®æœç”¨";

"alert_air_quality_title" = "å¤§æ°—è³ªæƒ…å ±";
"alert_air_quality_good" = "ç©ºæ°—ãŒãã‚Œã„";
"alert_air_quality_moderate" = "æ™®é€š";
"alert_air_quality_unhealthy_sensitive" = "æ•æ„Ÿãªæ–¹ã¯æ³¨æ„";
"alert_air_quality_unhealthy" = "å¥åº·ã«è‰¯ããªã„";
"alert_air_quality_action_indoor" = "å®¤å†…æ´»å‹•æ¨å¥¨";
"alert_air_quality_action_mask" = "å¤–å‡ºæ™‚ã¯ãƒã‚¹ã‚¯ç€ç”¨";

"alert_uv_title" = "ç´«å¤–ç·šæƒ…å ±";
"alert_uv_low" = "ç´«å¤–ç·šå¼±ã„";
"alert_uv_moderate" = "ç´«å¤–ç·šæ™®é€š";
"alert_uv_high" = "ç´«å¤–ç·šå¼·ã„";
"alert_uv_very_high" = "ç´«å¤–ç·šéå¸¸ã«å¼·ã„";
"alert_uv_action_sunscreen" = "æ—¥ç„¼ã‘æ­¢ã‚å¿…é ˆ";
"alert_uv_action_hat" = "å¸½å­ç€ç”¨æ¨å¥¨";
```

#### ã‚¢ãƒ‰ãƒã‚¤ã‚¹é–¢é€£ï¼ˆ40é …ç›®ï¼‰
```swift
// MARK: - Daily Advice
"advice_meal_title" = "é£Ÿäº‹ãƒ—ãƒ©ãƒ³";
"advice_meal_breakfast" = "æœé£Ÿ";
"advice_meal_lunch" = "æ˜¼é£Ÿ";
"advice_meal_dinner" = "å¤•é£Ÿ";
"advice_meal_snack" = "é–“é£Ÿ";
"advice_meal_hydration" = "æ°´åˆ†è£œçµ¦";

"advice_exercise_title" = "é‹å‹•ãƒ—ãƒ©ãƒ³";
"advice_exercise_intensity_low" = "è»½ã‚";
"advice_exercise_intensity_moderate" = "æ™®é€š";
"advice_exercise_intensity_high" = "ã—ã£ã‹ã‚Š";
"advice_exercise_type_walking" = "ã‚¦ã‚©ãƒ¼ã‚­ãƒ³ã‚°";
"advice_exercise_type_running" = "ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°";
"advice_exercise_type_yoga" = "ãƒ¨ã‚¬";
"advice_exercise_type_strength" = "ç­‹ãƒˆãƒ¬";
"advice_exercise_type_swimming" = "æ°´æ³³";
"advice_exercise_duration_format" = "%dåˆ†ç¨‹åº¦";

"advice_wellness_title" = "éã”ã—æ–¹ãƒ—ãƒ©ãƒ³";
"advice_wellness_breathing" = "å‘¼å¸æ³•";
"advice_wellness_meditation" = "ç‘æƒ³";
"advice_wellness_stretching" = "ã‚¹ãƒˆãƒ¬ãƒƒãƒ";
"advice_wellness_massage" = "ãƒãƒƒã‚µãƒ¼ã‚¸";
"advice_wellness_bath" = "å…¥æµ´";
"advice_wellness_sleep_prep" = "ç¡çœ æº–å‚™";

"advice_reason_prefix" = "ç†ç”±ï¼š";
"advice_benefit_prefix" = "åŠ¹æœï¼š";
"advice_timing_morning" = "æœ";
"advice_timing_afternoon" = "åˆå¾Œ";
"advice_timing_evening" = "å¤•æ–¹";
"advice_timing_night" = "å¤œ";
"advice_timing_before_meal" = "é£Ÿå‰";
"advice_timing_after_meal" = "é£Ÿå¾Œ";
```

#### UIè¦ç´ ãƒ»å…±é€šï¼ˆ40é …ç›®ï¼‰
```swift
// MARK: - Common UI Elements
"button_ok" = "OK";
"button_cancel" = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«";
"button_save" = "ä¿å­˜";
"button_next" = "æ¬¡ã¸";
"button_back" = "æˆ»ã‚‹";
"button_done" = "å®Œäº†";
"button_skip" = "ã‚¹ã‚­ãƒƒãƒ—";
"button_retry" = "å†è©¦è¡Œ";
"button_refresh" = "æ›´æ–°";
"button_detail" = "è©³ç´°ã‚’è¦‹ã‚‹";
"button_close" = "é–‰ã˜ã‚‹";
"button_settings" = "è¨­å®š";

"tab_home" = "ä»Šæ—¥";
"tab_history" = "å±¥æ­´";
"tab_trends" = "å‚¾å‘";
"tab_learn" = "å­¦ã¶";
"tab_profile" = "ç§";

"loading_message" = "èª­ã¿è¾¼ã¿ä¸­...";
"loading_analyzing" = "åˆ†æä¸­...";
"loading_generating" = "ç”Ÿæˆä¸­...";

"error_title" = "ã‚¨ãƒ©ãƒ¼";
"error_network" = "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼";
"error_network_description" = "é€šä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ";
"error_data_unavailable" = "ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“";
"error_healthkit_permission" = "ãƒ˜ãƒ«ã‚¹ã‚±ã‚¢ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“";
"error_location_permission" = "ä½ç½®æƒ…å ±ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“";
"error_retry_message" = "ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„";

"empty_state_title" = "ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“";
"empty_state_description" = "ãƒ‡ãƒ¼ã‚¿ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¾ã§ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„";
"empty_state_action" = "ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—";

"date_today" = "ä»Šæ—¥";
"date_yesterday" = "æ˜¨æ—¥";
"date_format_short" = "Mæœˆdæ—¥";
"date_format_full" = "yyyyå¹´Mæœˆdæ—¥ï¼ˆEï¼‰";
"time_format_12h" = "a h:mm";
"time_format_24h" = "HH:mm";
```

### è‹±èªç‰ˆå®Œå…¨ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆåŒé …ç›®æ•°ï¼‰

```swift
// ios/TempoAI/TempoAI/Resources/en.lproj/Localizable.strings
// MARK: - Onboarding (English)
"onboarding_welcome_title" = "Welcome to Tempo AI";
"onboarding_welcome_subtitle" = "Your Personal Healthcare Advisor";
"onboarding_welcome_description" = "Every morning, optimal advice from your data";
// ... (å…¨200+é …ç›®ã®è‹±èªç‰ˆ)
```

### ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³å“è³ªä¿è¨¼

```swift
// ios/TempoAI/TempoAITests/LocalizationTests.swift
class LocalizationCompletionTests: XCTestCase {
    
    func testAllKeysHaveTranslations() {
        let requiredKeys = LocalizationKeys.allCases // 200+ keys
        
        for key in requiredKeys {
            let japanese = key.localized(for: .japanese)
            let english = key.localized(for: .english)
            
            // ç¿»è¨³æ¼ã‚Œãƒã‚§ãƒƒã‚¯
            XCTAssertNotEqual(japanese, key.rawValue, "Missing Japanese: \(key)")
            XCTAssertNotEqual(english, key.rawValue, "Missing English: \(key)")
            
            // æ–‡å­—æ•°ãƒãƒ©ãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯ï¼ˆæ—¥æœ¬èªã¯è‹±èªã®1.5å€ç¨‹åº¦ãŒè‡ªç„¶ï¼‰
            let japaneseLength = japanese.count
            let englishLength = english.count
            let ratio = Double(japaneseLength) / Double(englishLength)
            
            XCTAssertTrue(ratio > 0.8 && ratio < 2.0, 
                         "Suspicious translation ratio for \(key): \(ratio)")
        }
    }
    
    func testJapaneseNaturalness() {
        // æ©Ÿæ¢°ç¿»è¨³æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³
        let unnaturalPatterns = [
            "ã‚ãªãŸã®", // éåº¦ãªä½¿ç”¨
            "ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™", // å†—é•·
            "ãã ã•ã„ã€‚", // éåº¦ãªä¸å¯§èª
        ]
        
        let allJapaneseStrings = LocalizationKeys.allCases.map { 
            $0.localized(for: .japanese) 
        }
        
        for string in allJapaneseStrings {
            for pattern in unnaturalPatterns {
                let occurrences = string.components(separatedBy: pattern).count - 1
                XCTAssertLessThan(occurrences, 2, 
                                "Unnatural pattern '\(pattern)' in: \(string)")
            }
        }
    }
}
```

---

## ğŸ¯ æŠ€è¡“å®Ÿè£…è©³ç´°ä»•æ§˜

### SwiftUI ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å®Œå…¨å®Ÿè£…

#### MVVM+Coordinatorè©³ç´°è¨­è¨ˆ

```swift
// ios/TempoAI/TempoAI/Architecture/Coordinators/AppCoordinator.swift
@MainActor
class AppCoordinator: ObservableObject {
    @Published var currentTab: AppTab = .home
    @Published var showOnboarding: Bool = false
    @Published var navigationPath: NavigationPath = NavigationPath()
    
    private let userDefaults = UserDefaults.standard
    private let onboardingKey = "hasCompletedOnboarding"
    
    init() {
        checkOnboardingStatus()
    }
    
    func checkOnboardingStatus() {
        showOnboarding = !userDefaults.bool(forKey: onboardingKey)
    }
    
    func completeOnboarding() {
        userDefaults.set(true, forKey: onboardingKey)
        showOnboarding = false
    }
    
    func navigate(to destination: any Hashable) {
        navigationPath.append(destination)
    }
}

// ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³åˆ—æŒ™å‹
enum AppTab: String, CaseIterable {
    case home = "tab_home"
    case history = "tab_history"
    case trends = "tab_trends"
    case learn = "tab_learn"
    case profile = "tab_profile"
    
    var icon: String {
        switch self {
        case .home: return "house.fill"
        case .history: return "calendar"
        case .trends: return "chart.line.uptrend.xyaxis"
        case .learn: return "book.fill"
        case .profile: return "person.fill"
        }
    }
}
```

#### ä¾å­˜æ€§æ³¨å…¥ã‚³ãƒ³ãƒ†ãƒŠ

```swift
// ios/TempoAI/TempoAI/DI/DependencyContainer.swift
class DependencyContainer {
    static let shared = DependencyContainer()
    
    // Services
    lazy var healthKitManager: HealthKitManager = HealthKitManager()
    lazy var locationManager: LocationManager = LocationManager()
    lazy var apiClient: APIClient = APIClient(configuration: apiConfiguration)
    lazy var cacheManager: CacheManager = CacheManager()
    lazy var localizationManager: LocalizationManager = LocalizationManager.shared
    
    // ViewModels Factory
    func makeHomeViewModel() -> HomeViewModel {
        HomeViewModel(
            healthKitManager: healthKitManager,
            apiClient: apiClient,
            cacheManager: cacheManager
        )
    }
    
    func makeOnboardingViewModel() -> OnboardingViewModel {
        OnboardingViewModel(
            healthKitManager: healthKitManager,
            locationManager: locationManager
        )
    }
    
    // Configuration
    private var apiConfiguration: APIConfiguration {
        APIConfiguration(
            baseURL: ProcessInfo.processInfo.environment["API_BASE_URL"] 
                ?? "https://tempo-ai-api.workers.dev",
            timeout: 30.0
        )
    }
}

// Environment ã§æ³¨å…¥
extension View {
    func injectDependencies() -> some View {
        self
            .environmentObject(DependencyContainer.shared)
            .environmentObject(DependencyContainer.shared.localizationManager)
    }
}
```

### Hono ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

#### å®Œå…¨ãªãƒ«ãƒ¼ãƒˆæ§‹æˆ

```typescript
// backend/src/index.ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { healthRoutes } from './routes/health'
import { environmentalRoutes } from './routes/environmental'
import { greetingsRoutes } from './routes/greetings'
import { RateLimitMiddleware } from './middleware/rate-limit'
import { ErrorHandlingMiddleware } from './middleware/error-handling'

interface Bindings {
  ANTHROPIC_API_KEY: string
  ENVIRONMENT: 'development' | 'production'
  WEATHER_API_KEY: string
  POLLEN_API_KEY?: string
  AQI_API_KEY?: string
}

const app = new Hono<{ Bindings: Bindings }>()

// Global Middleware
app.use('*', logger())
app.use('*', cors({
  origin: (origin) => {
    const allowed = [
      'https://tempo-ai.app',
      'http://localhost:3000',
      'http://localhost:8787'
    ]
    return allowed.includes(origin) ? origin : allowed[0]
  },
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400,
  credentials: true
}))

// Rate Limiting
const rateLimiter = new RateLimitMiddleware()
app.use('/api/*', rateLimiter.middleware())

// Error Handling
const errorHandler = new ErrorHandlingMiddleware()
app.use('*', errorHandler.middleware())

// Route Registration
app.route('/api/health', healthRoutes)
app.route('/api/environmental', environmentalRoutes)
app.route('/api/greetings', greetingsRoutes)

// Health Check
app.get('/', (c) => {
  return c.json({
    service: 'Tempo AI API',
    version: '1.0.0',
    status: 'healthy',
    endpoints: [
      'POST /api/health/analyze',
      'POST /api/health/status',
      'GET /api/environmental/alerts/:lat/:lon',
      'POST /api/greetings/generate'
    ],
    documentation: 'https://docs.tempo-ai.app'
  })
})

export default app
```

#### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢

```typescript
// backend/src/middleware/error-handling.ts
import { Context, Next } from 'hono'

export class ErrorHandlingMiddleware {
  middleware() {
    return async (c: Context, next: Next) => {
      try {
        await next()
      } catch (error) {
        console.error('Unhandled error:', error)
        
        if (error instanceof ValidationError) {
          return c.json({
            success: false,
            error: 'Validation failed',
            details: error.details
          }, 400)
        }
        
        if (error instanceof AuthorizationError) {
          return c.json({
            success: false,
            error: 'Unauthorized'
          }, 401)
        }
        
        if (error instanceof RateLimitError) {
          return c.json({
            success: false,
            error: 'Rate limit exceeded',
            retryAfter: error.retryAfter
          }, 429)
        }
        
        if (error instanceof ExternalAPIError) {
          return c.json({
            success: false,
            error: 'External service unavailable',
            service: error.service
          }, 503)
        }
        
        // Default error response
        return c.json({
          success: false,
          error: 'Internal server error',
          requestId: c.get('requestId')
        }, 500)
      }
    }
  }
}

// Custom Error Classes
export class ValidationError extends Error {
  constructor(public details: any) {
    super('Validation failed')
    this.name = 'ValidationError'
  }
}

export class AuthorizationError extends Error {
  constructor(message = 'Unauthorized') {
    super(message)
    this.name = 'AuthorizationError'
  }
}

export class RateLimitError extends Error {
  constructor(public retryAfter: number) {
    super('Rate limit exceeded')
    this.name = 'RateLimitError'
  }
}

export class ExternalAPIError extends Error {
  constructor(public service: string, message: string) {
    super(message)
    this.name = 'ExternalAPIError'
  }
}
```

---

## âœ… å“è³ªä¿è¨¼ãƒ»ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹

### å¤šæ®µéšå“è³ªã‚²ãƒ¼ãƒˆ

#### Gate 1: é–‹ç™ºæ™‚å“è³ª (Development Quality Gate)

**å®Ÿè£…åŸºæº–**
```bash
# è‡ªå‹•å®Ÿè¡Œ: Git pre-commit hook
#!/bin/bash
echo "ğŸ” Phase 1 Development Quality Check..."

# 1. Swift code quality
cd ios
swiftlint --strict
swift-format lint --recursive TempoAI/

# 2. TypeScript quality  
cd ../backend
npx biome check --error-on-warnings .
npx tsc --noEmit

# 3. Test coverage verification
npm run test:coverage
if [ "$(grep -o '"total":{"lines":{"pct":[0-9]*' coverage/coverage-summary.json | grep -o '[0-9]*' | tail -1)" -lt "95" ]; then
  echo "âŒ Backend coverage below 95%"
  exit 1
fi

cd ../ios
xcodebuild test -scheme TempoAI -destination 'platform=iOS Simulator,name=iPhone 15' -enableCodeCoverage YES
# Coverage requirement: 90%+ for Phase 1 new code

echo "âœ… Development quality gate passed"
```

**TDDéµå®ˆç¢ºèª**
```bash
# TDD cycle verification script
#!/bin/bash
echo "ğŸ”„ Verifying TDD Cycle Compliance..."

# Check for test files corresponding to implementation files
find ios/TempoAI/TempoAI -name '*.swift' | while read impl_file; do
    base_name=$(basename "$impl_file" .swift)
    test_file="ios/TempoAI/TempoAITests/${base_name}Tests.swift"
    
    if [ ! -f "$test_file" ]; then
        echo "âš ï¸  Missing test file for $impl_file"
        echo "   Expected: $test_file"
    fi
done

# Verify test-first commits (RED phase evidence)
git log --oneline -10 | grep -E "(RED|FAIL|failing test)" || echo "âš ï¸  No RED phase commits found recently"

echo "âœ… TDD compliance verified"
```

#### Gate 2: çµ±åˆå“è³ª (Integration Quality Gate)

**è‡ªå‹•çµ±åˆãƒ†ã‚¹ãƒˆ**
```bash
#!/bin/bash
echo "ğŸ”— Phase 1 Integration Quality Check..."

# 1. End-to-end UI test suite
cd ios
xcodebuild test -scheme TempoAI -destination 'platform=iOS Simulator,name=iPhone 15' -testPlan TempoAIPhase1IntegrationTests

# 2. API integration tests
cd ../backend
npm run test:integration

# 3. Cross-platform consistency tests
npm run test:api:consistency

# 4. Localization integrity check
cd ../ios
./scripts/verify-localization.sh

echo "âœ… Integration quality gate passed"
```

**å¤šè¨€èªè¡¨ç¤ºå“è³ªç¢ºèª**
```swift
// ios/TempoAI/TempoAIUITests/LocalizationIntegrityTests.swift
class LocalizationIntegrityTests: XCTestCase {
    
    func testAllLocalizationKeysPresent() {
        let requiredKeys = [
            "onboarding_welcome_title",
            "onboarding_welcome_subtitle",
            "health_status_optimal",
            "health_status_care",
            "greeting_sunny_morning",
            // ... 200+ keys
        ]
        
        for key in requiredKeys {
            // æ—¥æœ¬èª
            let japanese = NSLocalizedString(key, bundle: .japanese, value: "MISSING", comment: "")
            XCTAssertNotEqual(japanese, "MISSING", "Missing Japanese translation for \(key)")
            XCTAssertNotEqual(japanese, key, "Japanese translation not found for \(key)")
            
            // è‹±èª
            let english = NSLocalizedString(key, bundle: .english, value: "MISSING", comment: "")
            XCTAssertNotEqual(english, "MISSING", "Missing English translation for \(key)")
            XCTAssertNotEqual(english, key, "English translation not found for \(key)")
        }
    }
    
    func testJapaneseExpressionNaturalness() {
        // æ©Ÿæ¢°ç¿»è¨³ã£ã½ã„è¡¨ç¾ã®æ¤œå‡º
        let unnaturalPatterns = [
            "ã‚ãªãŸã®", // éåº¦ãªã€Œã‚ãªãŸã®ã€ä½¿ç”¨
            "ã§ã‚ã‚‹", // ç¡¬ã„è¡¨ç¾
            "ã‚’ã—ã¦ãã ã•ã„", // ä¸è‡ªç„¶ãªå‘½ä»¤å½¢
        ]
        
        let japaneseStrings = getAllJapaneseLocalizedStrings()
        
        for (key, value) in japaneseStrings {
            for pattern in unnaturalPatterns {
                if value.contains(pattern) {
                    XCTFail("Potentially unnatural Japanese expression in \(key): \(pattern)")
                }
            }
        }
    }
}
```

#### Gate 3: æœ¬ç•ªæº–å‚™å“è³ª (Production Readiness Gate)

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŸºæº–ç¢ºèª**
```bash
#!/bin/bash
echo "âš¡ Phase 1 Performance Quality Check..."

# 1. App launch time
cd ios
instruments -t "App Launch" -D launch_performance.trace TempoAI.app
# Target: < 2.0 seconds to usable state

# 2. Memory usage analysis  
instruments -t "Allocations" -D memory_analysis.trace TempoAI.app
# Target: < 150MB peak memory usage

# 3. API response time verification
cd ../backend
npm run test:performance
# Target: 95th percentile < 2.0 seconds

# 4. Battery usage assessment
cd ../ios
instruments -t "Energy Log" -D energy_analysis.trace TempoAI.app
# Target: < 5% battery drain per hour of typical usage

echo "âœ… Performance quality gate passed"
```

**ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ç¢ºèª**
```bash
#!/bin/bash
echo "ğŸ”’ Phase 1 Security & Privacy Check..."

# 1. Static security analysis
cd backend
npm audit --audit-level high
semgrep --config=security .

# 2. API key exposure check
grep -r "sk-" . --exclude-dir=node_modules && echo "âŒ API key exposed" && exit 1
grep -r "ANTHROPIC_API_KEY" . --exclude="*.md" --exclude-dir=node_modules

# 3. Health data handling verification
cd ../ios
# Verify HealthKit data is processed locally
grep -r "PHHealthStore" . | grep -v "local" && echo "âš ï¸  HealthKit data may leave device"

# 4. Japanese privacy law compliance
./scripts/privacy-compliance-check.sh

echo "âœ… Security & privacy gate passed"
```

### å“è³ªæŒ‡æ¨™ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

#### ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å“è³ªãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

```typescript
// backend/monitoring/quality-metrics.ts
export class QualityMetricsCollector {
  async collectPhase1Metrics(): Promise<QualityReport> {
    return {
      codeQuality: {
        testCoverage: await getTestCoverage(),
        codeComplexity: await calculateComplexity(),
        duplicateCode: await detectDuplicates(),
        lintingIssues: await runLinters(),
      },
      
      functionality: {
        onboardingCompletionRate: await getOnboardingMetrics(),
        healthStatusAccuracy: await validateHealthCalculations(),
        localizationCoverage: await checkTranslationCoverage(),
        apiReliability: await testApiEndpoints(),
      },
      
      performance: {
        appLaunchTime: await measureLaunchTime(),
        memoryUsage: await profileMemoryUsage(),
        batteryEfficiency: await assessBatteryImpact(),
        networkEfficiency: await analyzeNetworkCalls(),
      },
      
      userExperience: {
        uiConsistency: await validateUiGuidelines(),
        accessibilityScore: await auditAccessibility(),
        errorHandlingCoverage: await testErrorScenarios(),
        culturalAdaptation: await validateJapaneseUx(),
      },
    }
  }
}
```

#### é€±æ¬¡å“è³ªãƒ¬ãƒ“ãƒ¥ãƒ¼

**é‡‘æ›œæ—¥å®šæœŸãƒ¬ãƒ“ãƒ¥ãƒ¼é …ç›®**

1. **TDDå®Ÿè·µçŠ¶æ³**
   - [ ] REDâ†’GREENâ†’BLUEâ†’VERIFYã‚µã‚¤ã‚¯ãƒ«å®Œäº†æ•°: 30+/é€±
   - [ ] ãƒ†ã‚¹ãƒˆå…ˆè¡Œç‡: 100%ï¼ˆå®Ÿè£…å‰ã«ãƒ†ã‚¹ãƒˆä½œæˆï¼‰
   - [ ] ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å®Ÿæ–½ç‡: 100%ï¼ˆBLUEæ®µéšçœç•¥ãªã—ï¼‰
   
2. **ã‚³ãƒ¼ãƒ‰å“è³ª**
   - [ ] SwiftLinté•å: 0ä»¶
   - [ ] TypeScript strict mode ã‚¨ãƒ©ãƒ¼: 0ä»¶
   - [ ] è¤‡é›‘åº¦ã‚¹ã‚³ã‚¢: é–¢æ•°ã‚ãŸã‚Šå¹³å‡10ä»¥ä¸‹
   - [ ] é‡è¤‡ã‚³ãƒ¼ãƒ‰: 5%ä»¥ä¸‹

3. **æ©Ÿèƒ½å“è³ª** 
   - [ ] æ–°æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: iOS 90%+ / Backend 95%+
   - [ ] çµ±åˆãƒ†ã‚¹ãƒˆæˆåŠŸç‡: 100%
   - [ ] å¤šè¨€èªè¡¨ç¤ºãƒ†ã‚¹ãƒˆ: å…¨è¦ç´ ç¢ºèªæ¸ˆã¿
   - [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ: å…¨åŸºæº–ã‚¯ãƒªã‚¢

4. **ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“å“è³ª**
   - [ ] ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ç›£æŸ»: ã‚¹ã‚³ã‚¢95%ä»¥ä¸Š
   - [ ] æ—¥æœ¬èªè¡¨ç¾ãƒ¬ãƒ“ãƒ¥ãƒ¼: ãƒã‚¤ãƒ†ã‚£ãƒ–ç¢ºèªæ¸ˆã¿
   - [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°: å…¨ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆå®Œäº†
   - [ ] ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¸€è²«æ€§: ç¢ºèªæ¸ˆã¿

#### Phase 2 é€²è¡Œåˆ¤å®šåŸºæº–

**Phase 1 â†’ Phase 2 ç§»è¡Œæ¡ä»¶**

**å¿…é ˆæ¡ä»¶ (Must Have)**:
- [ ] 4ãƒšãƒ¼ã‚¸ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ­ãƒ¼å®Œå…¨å‹•ä½œ
- [ ] ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹4è‰²è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ å‹•ä½œ
- [ ] å¤©æ°—å¯¾å¿œãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºæŒ¨æ‹¶ç”Ÿæˆ
- [ ] ç’°å¢ƒã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ å‹•ä½œ
- [ ] æ—¥è‹±å®Œå…¨å¤šè¨€èªå¯¾å¿œ
- [ ] å…¨å“è³ªã‚²ãƒ¼ãƒˆåˆæ ¼

**å“è³ªæ¡ä»¶ (Quality Gates)**:
- [ ] iOS UIãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: 90%ä»¥ä¸Š
- [ ] Backend APIãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: 95%ä»¥ä¸Š
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹: å…¨åŸºæº–é”æˆ
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»: è„†å¼±æ€§0ä»¶
- [ ] ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£: WCAG 2.1 AAæº–æ‹ 

**ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£æ¡ä»¶ (UX Validation)**:
- [ ] å†…éƒ¨ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ: æº€è¶³åº¦4.0/5.0ä»¥ä¸Š
- [ ] ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Œäº†ç‡: 85%ä»¥ä¸Š
- [ ] æ—¥æœ¬èªUIè‡ªç„¶æ€§: ãƒã‚¤ãƒ†ã‚£ãƒ–è©•ä¾¡4.5/5.0ä»¥ä¸Š
- [ ] ã‚¨ãƒ©ãƒ¼å›å¾©ç‡: 95%ä»¥ä¸Š

**æŠ€è¡“çš„è² å‚µæ¡ä»¶ (Technical Health)**:
- [ ] CLAUDE.mdè¦ç´„éµå®ˆç‡: 100%
- [ ] ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ç©ã¿æ®‹ã—: 0ä»¶
- [ ] æ—¢çŸ¥ãƒã‚°: P0/P1 0ä»¶ã€P2 3ä»¶ä»¥ä¸‹
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³: 100%å®Œå‚™